---
- name: Obnovit' apt kesh pered ustanovkoi docker
  ansible.builtin.apt:
    update_cache: true
    cache_valid_time: 3600

- name: Ustanovit' bazovye pakety dlya docker (tol'ko dlya etoi roli)
  ansible.builtin.apt:
    name:
      - ca-certificates
      - curl
      - gnupg
      - lsb-release
    state: present

- name: Prostaia ustanovka docker engine dlya pgadmin (docker.io iz repo)
  ansible.builtin.apt:
    name:
      - docker.io
      - python3-docker
    state: present

- name: Ubedit'sya chto servis docker vklyuchen
  ansible.builtin.service:
    name: docker
    state: started
    enabled: true

- name: Sozdat' direktoriyu dlya dannyh pgAdmin
  ansible.builtin.file:
    path: "{{ pgadmin_data_dir }}"
    state: directory
    owner: root
    group: root
    mode: "0755"

- name: Ustanovit' pravy na dannye pgAdmin
  ansible.builtin.file:
    path: "{{ pgadmin_data_dir }}"
    # UID/GID 5050 - eto polzovatel pgadmin v kontejnere, chtoby on mog pisat v /var/lib/pgadmin
    owner: 5050
    group: 5050
    recurse: true

- name: Sozdat' direktoriyu dlya konfiguracii pgAdmin
  ansible.builtin.file:
    path: "{{ pgadmin_config_dir }}"
    state: directory
    owner: root
    group: root
    mode: "0755"

- name: Razvernut' servers.json s predna stroennym gh-db
  ansible.builtin.template:
    src: servers.json.j2
    dest: "{{ pgadmin_config_dir }}/servers.json"
    owner: root
    group: root
    mode: "0644"
  notify: restart pgadmin container

- name: Zapustit' ili obnovit' kontener pgAdmin
  community.docker.docker_container:
    name: "{{ pgadmin_container_name }}"
    image: "{{ pgadmin_image }}"
    restart_policy: always
    published_ports:
      - "{{ pgadmin_port }}:80"
    env:
      PGADMIN_DEFAULT_EMAIL: "{{ pgadmin_default_email }}"
      PGADMIN_DEFAULT_PASSWORD: "{{ pgadmin_default_password }}"
    volumes:
      - "{{ pgadmin_data_dir }}:/var/lib/pgadmin"
      - "{{ pgadmin_config_dir }}/servers.json:/pgadmin4/servers.json"
    state: started
    pull: true

- name: Avtoimport serverov dlya pgAdmin
  block:
    - name: Proverit' marker importa serverov
      ansible.builtin.stat:
        path: "{{ pgadmin_data_dir }}/.servers_imported"
      register: pgadmin_servers_marker

    - name: Zagruzit' servers.json v pgAdmin odin raz
      community.docker.docker_container_exec:
        container: "{{ pgadmin_container_name }}"
        command: "/venv/bin/python /pgadmin4/setup.py load-servers /pgadmin4/servers.json --user {{ pgadmin_default_email }}"
      register: pgadmin_servers_import
      changed_when: pgadmin_servers_import.rc == 0
      failed_when: false
      when: not pgadmin_servers_marker.stat.exists

    - name: Soobshit' ob oshibke importa serverov
      ansible.builtin.fail:
        msg: "Import serverov v pgAdmin ne udalsya: {{ pgadmin_servers_import.stderr | default(pgadmin_servers_import.msg) | default('neizvestnaya oshibka') }}"
      when:
        - not pgadmin_servers_marker.stat.exists
        - pgadmin_servers_import is defined
        - pgadmin_servers_import.rc != 0

    - name: Sozdat' marker posle importa serverov
      ansible.builtin.file:
        path: "{{ pgadmin_data_dir }}/.servers_imported"
        state: touch
        owner: 5050
        group: 5050
      when:
        - not pgadmin_servers_marker.stat.exists
        - pgadmin_servers_import is defined
        - pgadmin_servers_import.rc == 0

- name: Proverit' sostoyanie kontenera pgAdmin
  community.docker.docker_container_info:
    name: "{{ pgadmin_container_name }}"
  register: pgadmin_info

- name: Soobshit' ob uspeshnom starte pgAdmin
  ansible.builtin.debug:
    msg: "Kontener {{ pgadmin_container_name }} zapushchen i dostupen po portu {{ pgadmin_port }}"
  when: pgadmin_info.exists and pgadmin_info.container.State.Running | default(false)

- name: Ostanovit' vypolnenie esli kontener ne zapushchen
  ansible.builtin.fail:
    msg: "Kontener {{ pgadmin_container_name }} ne zapustilsya, prover' ustanovku Docker i nastroiki roli"
  when: not (pgadmin_info.exists and pgadmin_info.container.State.Running | default(false))
