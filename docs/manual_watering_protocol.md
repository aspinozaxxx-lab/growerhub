# Протокол ручного полива

## Назначение
Этот документ описывает, как сервер и прошивка обменяются командами ручного полива через MQTT и веб-панель. Сервер отправляет устройству команды включить/выключить насос, устройство подтверждает выполнение и публикует фактическое состояние.

## MQTT топики
- `gh/dev/{device_id}/cmd`
  - публикует: сервер
  - кто слушает: устройство
  - QoS: 1
  - retain: false — команда не должна сработать повторно после перезапуска брокера.

- `gh/dev/{device_id}/ack`
  - публикует: устройство
  - кто слушает: сервер
  - QoS: 1
  - retain: false — подтверждения не копятся, важны только в момент отправки.

- `gh/dev/{device_id}/state`
  - публикует: устройство
  - кто слушает: сервер
  - QoS: 1
  - retain: true — серверу важно помнить последнее состояние после рестарта, поэтому state сохраняется в брокере.

## Команды
### pump.start
Пример полезной нагрузки:
```json
{
  "type": "pump.start",
  "duration_s": 30,
  "correlation_id": "abc123deadbeef",
  "ts": "2025-10-24T10:15:00Z"
}
```
- `duration_s` — сколько секунд поливать.
- `correlation_id` — уникальный идентификатор команды (сервер использует его, чтобы сопоставить ACK).
- `ts` — время отправки в UTC.

Устройство должно включить насос, отправить ACK с `result="accepted"` и опубликовать state со статусом `"running"`.

### pump.stop
Аналогичный формат:
```json
{
  "type": "pump.stop",
  "correlation_id": "abc123deadbeef",
  "ts": "2025-10-24T10:16:00Z"
}
```
- устройство выключает насос,
- отправляет ACK,
- публикует state с `status="idle"`.

## Ack от устройства
Пример подтверждения:
```json
{
  "correlation_id": "abc123deadbeef",
  "result": "accepted",
  "reason": null,
  "status": "running",
  "duration_s": 30,
  "started_at": "2025-10-24T10:15:01Z"
}
```
- `result` может быть `"accepted"`, `"rejected"` или `"error"`.
- `reason` (опционально) поясняет, почему команда отклонена.
- Дополнительные поля `status`, `duration_s`, `started_at` помогают серверу обновить UI.
- Сервер ждёт ACK ограниченное время (см. `/api/manual-watering/wait-ack`) и показывает пользователю итог.

## State от устройства
Пример состояния:
```json
{
  "manual_watering": {
    "status": "running",
    "duration_s": 30,
    "started_at": "2025-10-24T10:15:01Z",
    "remaining_s": 18,
    "correlation_id": "abc123deadbeef"
  }
}
```
- `status`: `"idle"`, `"running"` или `"stopping"`.
- `duration_s`/`started_at` — текущая сессия полива.
- `remaining_s` — опционально; сервер умеет досчитывать, но полезно публиковать.
- `correlation_id` — к какой команде относится полив.

Устройство должно публиковать state:
1. сразу после запуска помпы (`status="running"`),
2. периодически во время полива (раз в 2–5 секунд — для прогресса на панели),
3. после окончания (`status="idle"`).
Сообщение публикуется с `retain=true`, чтобы сервер видел актуальную картину после перезапуска.

## Логика «онлайн / оффлайн»
- Сервер считает устройство доступным (`is_online=true`), если последний state моложе порога `DEVICE_ONLINE_THRESHOLD_S` (в секундах).
- Если устройство ещё ни разу не присылало state, сервер помечает `offline_reason="no_state_yet"` и блокирует кнопки.
- Если state был, но давно, `offline_reason="device_offline"` — устройство нужно найти и вернуть в сеть.

## API на сервере для фронтенда
- `POST /api/manual-watering/start` — отправляет команду включить насос.
- `POST /api/manual-watering/stop` — останавливает насос.
- `GET /api/manual-watering/status?device_id=...` — возвращает текущий статус, прогресс и `offline_reason`.
- `GET /api/manual-watering/wait-ack?correlation_id=...` — мягко ждёт подтверждение от устройства (long-poll).

Типичный сценарий веб-панели: пользователь жмёт «Полить» → фронт вызывает `/start` → ждёт ACK через `/wait-ack` → обновляет прогресс через `/status` (несколько раз, пока длится полив).
