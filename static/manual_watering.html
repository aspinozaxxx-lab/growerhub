<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8" />
    <title>Р СѓС‡РЅРѕР№ РїРѕР»РёРІ</title>
    <style>
        body {
            font-family: "Segoe UI", sans-serif;
            margin: 40px;
            background: #f5f6fa;
            color: #1e272e;
        }

        h1 {
            margin-bottom: 20px;
        }

        label {
            display: block;
            margin-top: 15px;
            font-weight: 600;
        }

        input[type="text"],
        select {
            padding: 8px 12px;
            margin-top: 6px;
            border-radius: 6px;
            border: 1px solid #d2dae2;
            width: 260px;
            font-size: 14px;
            box-sizing: border-box;
        }

        button {
            padding: 10px 18px;
            margin-top: 20px;
            margin-right: 10px;
            border: none;
            border-radius: 6px;
            background: #1e90ff;
            color: #fff;
            font-size: 15px;
            cursor: pointer;
            transition: background 0.2s ease;
        }

        button:hover:enabled {
            background: #0d6efd;
        }

        button:disabled {
            background: #b0b8c1;
            cursor: not-allowed;
        }

        #onlineStatus,
        #ackResult,
        #progressText {
            margin-top: 18px;
            font-size: 16px;
        }

        #ackResult {
            font-weight: 600;
        }

        #progressContainer {
            margin-top: 24px;
            width: 400px;
            height: 20px;
            background: #dfe4ea;
            border-radius: 10px;
            overflow: hidden;
        }

        #progressBar {
            height: 100%;
            width: 0;
            background: linear-gradient(90deg, #1e90ff, #70a1ff);
            transition: width 0.4s ease;
        }

        .inline-group {
            display: flex;
            align-items: center;
            gap: 20px;
            margin-top: 10px;
        }
    </style>
</head>
<body>
    <h1>Р СѓС‡РЅРѕР№ РїРѕР»РёРІ</h1>

    <label for="device_id">ID СѓСЃС‚СЂРѕР№СЃС‚РІР°</label>
    <input id="device_id" type="text" placeholder="РќР°РїСЂРёРјРµСЂ, abc123" />

    <label for="duration">Р”Р»РёС‚РµР»СЊРЅРѕСЃС‚СЊ РїРѕР»РёРІР°</label>
    <select id="duration">
        <option value="10">10 СЃРµРєСѓРЅРґ</option>
        <option value="20" selected>20 СЃРµРєСѓРЅРґ</option>
        <option value="30">30 СЃРµРєСѓРЅРґ</option>
        <option value="60">60 СЃРµРєСѓРЅРґ</option>
    </select>

    <div class="inline-group">
        <button id="startBtn">РџРѕР»РёС‚СЊ</button>
        <button id="stopBtn">РћСЃС‚Р°РЅРѕРІРёС‚СЊ</button>
        <button id="rebootBtn" class="btn btn-warning">РџРµСЂРµР·Р°РіСЂСѓР·РёС‚СЊ СѓСЃС‚СЂРѕР№СЃС‚РІРѕ</button>
    </div>

    <div id="onlineStatus">Р’РІРµРґРёС‚Рµ ID СѓСЃС‚СЂРѕР№СЃС‚РІР°</div>
    <div id="ackResult"></div>

    <div id="progressContainer">
        <div id="progressBar"></div>
    </div>
    <div id="progressText">РќРµС‚ Р°РєС‚РёРІРЅРѕРіРѕ РїРѕР»РёРІР°</div>
    <div id="debugPanel" style="display: none; margin-top: 24px; padding: 12px; border: 1px dashed #ced6e0; background: #f1f2f6; font-size: 13px;">
        <div style="font-weight: 600; margin-bottom: 6px;">Debug</div>
        <div>Last corr_id: <span id="debugCorrId">&mdash;</span></div>
        <div>Last wait-ack URL: <span id="debugWaitAckUrl">&mdash;</span></div>
        <div>Last ack: <span id="debugAckInfo">&mdash;</span></div>
    </div>

    <script>
        const deviceInput = document.getElementById("device_id");
        const durationSelect = document.getElementById("duration");
        const startBtn = document.getElementById("startBtn");
        const stopBtn = document.getElementById("stopBtn");
        const rebootBtn = document.getElementById("rebootBtn");
        const onlineStatusBlock = document.getElementById("onlineStatus");
        const ackResultBlock = document.getElementById("ackResult");
        const progressBar = document.getElementById("progressBar");
        const progressText = document.getElementById("progressText");
        const debugPanel = document.getElementById("debugPanel");
        const debugCorrId = document.getElementById("debugCorrId");
        const debugWaitAckUrl = document.getElementById("debugWaitAckUrl");
        const debugAckInfo = document.getElementById("debugAckInfo");

        const slowPollIntervalMs = 5000;
        const fastPollIntervalMs = 2000;

        let slowPollTimer = null;
        let fastPollTimer = null;

        const DEBUG_PREFIX = "[ACKDBG-FE]";
        const WAIT_ACK_TIMEOUT_S = 5;
        const debugState = {
            enabled:
                (typeof process !== "undefined" &&
                    process.env &&
                    process.env.NODE_ENV &&
                    process.env.NODE_ENV !== "production") ||
                false,
            lastCorrelationId: "\u2014",
            lastWaitAckUrl: "\u2014",
            lastAck: "\u2014"
        };

        function debugLogInfo(message, data) {
            if (!debugState.enabled) {
                return;
            }
            console.info(`${DEBUG_PREFIX} ${message}`, data);
        }

        function debugLogDebug(message, data) {
            if (!debugState.enabled) {
                return;
            }
            console.debug(`${DEBUG_PREFIX} ${message}`, data);
        }

        function debugLogWarn(message, data) {
            if (!debugState.enabled) {
                return;
            }
            console.warn(`${DEBUG_PREFIX} ${message}`, data);
        }

        function debugLogError(message, data) {
            if (!debugState.enabled) {
                return;
            }
            console.error(`${DEBUG_PREFIX} ${message}`, data);
        }

        function updateDebugPanel() {
            if (!debugState.enabled || !debugPanel) {
                return;
            }
            debugPanel.style.display = "block";
            if (debugCorrId) {
                debugCorrId.textContent = debugState.lastCorrelationId ?? "\u2014";
            }
            if (debugWaitAckUrl) {
                debugWaitAckUrl.textContent = debugState.lastWaitAckUrl ?? "\u2014";
            }
            if (debugAckInfo) {
                debugAckInfo.textContent = debugState.lastAck ?? "\u2014";
            }
        }

        async function ensureDebugEnabled() {
            if (debugState.enabled) {
                updateDebugPanel();
                return;
            }
            try {
                // TRANSLIT: proveryaem nalichie debug endpointa chtoby vkluchit panel
                const response = await fetch("/_debug/manual-watering/config", { method: "GET" });
                if (response.ok) {
                    debugState.enabled = true;
                    updateDebugPanel();
                }
            } catch (error) {
                // TRANSLIT: pri oshibke prosto ostavlyaem debug vykluchennym
                void error;
            }
        }

        function setLastCorrelationId(correlationId) {
            if (!debugState.enabled) {
                return;
            }
            debugState.lastCorrelationId = correlationId ?? "\u2014";
            debugState.lastAck = "\u2014";
            updateDebugPanel();
        }

        function setLastWaitAckUrl(url) {
            if (!debugState.enabled) {
                return;
            }
            debugState.lastWaitAckUrl = url ?? "\u2014";
            updateDebugPanel();
        }

        function setLastAckSummary(summary) {
            if (!debugState.enabled) {
                return;
            }
            debugState.lastAck = summary ?? "\u2014";
            updateDebugPanel();
        }

        function setButtonsDisabled(disabled) {
            startBtn.disabled = disabled;
            stopBtn.disabled = disabled;
            rebootBtn.disabled = disabled;
        }

        function resetProgress() {
            progressBar.style.width = "0%";
            progressText.textContent = "РќРµС‚ Р°РєС‚РёРІРЅРѕРіРѕ РїРѕР»РёРІР°";
        }

        function cancelSlowPoll() {
            if (slowPollTimer) {
                clearTimeout(slowPollTimer);
                slowPollTimer = null;
            }
        }

        function scheduleSlowPoll() {
            cancelSlowPoll();
            slowPollTimer = setTimeout(() => fetchStatus().catch(console.error), slowPollIntervalMs);
        }

        function startFastPoll() {
            if (!fastPollTimer) {
                fastPollTimer = setInterval(() => {
                    fetchStatus().catch(console.error);
                }, fastPollIntervalMs);
            }
        }

        function stopFastPoll() {
            if (fastPollTimer) {
                clearInterval(fastPollTimer);
                fastPollTimer = null;
            }
        }

        document.addEventListener("input", (event) => {
            if (event.target === deviceInput) {
                cancelSlowPoll();
                stopFastPoll();
                fetchStatus().catch(console.error);
            }
        });

        startBtn.addEventListener("click", () => {
            if (!validateDeviceId()) {
                return;
            }
            startWatering();
        });

        stopBtn.addEventListener("click", () => {
            if (!validateDeviceId()) {
                return;
            }
            stopWatering();
        });

        rebootBtn.addEventListener("click", onRebootClick);

        function validateDeviceId() {
            if (!deviceInput.value.trim()) {
                showAck("РќСѓР¶РЅРѕ СѓРєР°Р·Р°С‚СЊ ID СѓСЃС‚СЂРѕР№СЃС‚РІР° вќ—");
                return false;
            }
            return true;
        }

        async function fetchStatus() {
            cancelSlowPoll();
            const deviceId = deviceInput.value.trim();
            if (!deviceId) {
                onlineStatusBlock.textContent = "Р’РІРµРґРёС‚Рµ ID СѓСЃС‚СЂРѕР№СЃС‚РІР°";
                showAck("Р”Р»СЏ РѕРїСЂРѕСЃР° СЃС‚Р°С‚СѓСЃР° РЅСѓР¶РЅРѕ СѓРєР°Р·Р°С‚СЊ ID." );
                setButtonsDisabled(true);
                resetProgress();
                return;
            }

            try {
                // РџРµСЂРµРґ РєР°Р¶РґС‹Рј Р·Р°РїСЂРѕСЃРѕРј РїРѕРґС‡РёС‰Р°РµРј ID Рё РєРѕРґРёСЂСѓРµРј РµРіРѕ РІ URL: СЂРµР°Р»СЊРЅС‹Рµ РёРґРµРЅС‚РёС„РёРєР°С‚РѕСЂС‹ С‡Р°СЃС‚Рѕ РєРѕРїРёСЂСѓСЋС‚СЃСЏ СЃ РїСЂРѕР±РµР»Р°РјРё Рё СЃС‚СЂРѕРєР°РјРё.
                const response = await fetch(`/api/manual-watering/status?device_id=${encodeURIComponent(deviceId)}`);
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}`);
                }
                const data = await response.json();
                console.log("[РЎРўРђРўРЈРЎ РћРў РЎР•Р Р’Р•Р Рђ]", data);
                renderStatus(data);
            } catch (error) {
                console.error("РќРµ СѓРґР°Р»РѕСЃСЊ РїРѕР»СѓС‡РёС‚СЊ СЃС‚Р°С‚СѓСЃ", error);
                showAck("РћС€РёР±РєР° Р·Р°РїСЂРѕСЃР° СЃС‚Р°С‚СѓСЃР° вќЊ");
                setButtonsDisabled(true);
                resetProgress();
                stopFastPoll();
            } finally {
                scheduleSlowPoll();
            }
        }

        function renderStatus(data) {
            const isOnline = Boolean(data.is_online);
            const offlineReason = data.offline_reason;
            const lastSeenText = data.last_seen_at ? describeLastSeen(data.last_seen_at) : "вЂ”";

        if (isOnline) {
            onlineStatusBlock.textContent = `РЎС‚Р°С‚СѓСЃ СѓСЃС‚СЂРѕР№СЃС‚РІР°: РћРЅР»Р°Р№РЅ вњ… (РїРѕСЃР»РµРґРЅСЏСЏ Р°РєС‚РёРІРЅРѕСЃС‚СЊ: ${lastSeenText})`;
            startBtn.disabled = false;
            stopBtn.disabled = false;
            rebootBtn.disabled = false;
            updateProgressBar(data);
            if (data.status === "running") {
                startFastPoll();
            } else {
                stopFastPoll();
                }
                return;
            }

        stopFastPoll();
        setButtonsDisabled(true);

        if (offlineReason === "device_offline") {
            onlineStatusBlock.textContent = "РЎС‚Р°С‚СѓСЃ СѓСЃС‚СЂРѕР№СЃС‚РІР°: РћС„С„Р»Р°Р№РЅ вќЊ (СѓСЃС‚СЂРѕР№СЃС‚РІРѕ Р±С‹Р»Рѕ РЅР° СЃРІСЏР·Рё, РЅРѕ СЃРµР№С‡Р°СЃ РЅРµРґРѕСЃС‚СѓРїРЅРѕ)";
            showAck("РЈСЃС‚СЂРѕР№СЃС‚РІРѕ РѕС„С„Р»Р°Р№РЅ вЂ” РєРЅРѕРїРєРё Р±Р»РѕРєРёСЂСѓРµРј.");
        } else if (offlineReason === "no_state_yet") {
                onlineStatusBlock.textContent = "РЎС‚Р°С‚СѓСЃ СѓСЃС‚СЂРѕР№СЃС‚РІР°: РЅРµС‚ РґР°РЅРЅС‹С… вќ“ (СѓСЃС‚СЂРѕР№СЃС‚РІРѕ РµС‰С‘ РЅРё СЂР°Р·Сѓ РЅРµ РІС‹С…РѕРґРёР»Рѕ РЅР° СЃРІСЏР·СЊ)";
                showAck("Р–РґС‘Рј РїРµСЂРІРѕРµ РїРѕРґРєР»СЋС‡РµРЅРёРµ СѓСЃС‚СЂРѕР№СЃС‚РІР° вЂ” РєРЅРѕРїРєРё Р·Р°Р±Р»РѕРєРёСЂРѕРІР°РЅС‹.");
            } else {
                onlineStatusBlock.textContent = "РЎС‚Р°С‚СѓСЃ СѓСЃС‚СЂРѕР№СЃС‚РІР°: РћС„С„Р»Р°Р№РЅ вќЊ (РїСЂРёС‡РёРЅР° РЅРµРёР·РІРµСЃС‚РЅР°)";
            }

            setButtonsDisabled(true);
            resetProgress();
        }

        function updateProgressBar(status) {
            if (status.status !== "running" || status.duration_s == null) {
                resetProgress();
                return;
            }

            const duration = status.duration_s;
            const remaining = status.remaining_s ?? duration;
            const elapsed = Math.max(0, duration - remaining);
            const percent = Math.min(100, Math.max(0, (elapsed / duration) * 100));
            progressBar.style.width = `${percent}%`;
            progressText.textContent = `РћСЃС‚Р°Р»РѕСЃСЊ ${remaining} СЃ РёР· ${duration}`;
        }

        function describeLastSeen(lastSeenIso) {
            const seen = new Date(lastSeenIso);
            if (Number.isNaN(seen.getTime())) {
                return "РІСЂРµРјСЏ РЅРµРёР·РІРµСЃС‚РЅРѕ";
            }
            const now = new Date();
            const diffSeconds = Math.max(0, Math.floor((now - seen) / 1000));
            if (diffSeconds < 1) {
                return "РјРµРЅРµРµ СЃРµРєСѓРЅРґС‹ РЅР°Р·Р°Рґ";
            }
            return `${diffSeconds} СЃ РЅР°Р·Р°Рґ`;
        }

        function showAck(message) {
            ackResultBlock.textContent = message;
        }

        async function startWatering() {
            const deviceId = deviceInput.value.trim();
            const duration = Number(durationSelect.value);

            setButtonsDisabled(true);
            showAck("РћС‚РїСЂР°РІР»СЏРµРј РєРѕРјР°РЅРґСѓ РЅР° Р·Р°РїСѓСЃРє...");

            try {
                const response = await fetch("/api/manual-watering/start", {
                    method: "POST",
                    headers: { "Content-Type": "application/json" },
                    body: JSON.stringify({ device_id: deviceId, duration_s: duration })
                });

                if (!response.ok) {
                    const errorPayload = await response.json().catch(() => ({}));
                    throw new Error(errorPayload.detail || `HTTP ${response.status}`);
                }

                const payload = await response.json();
                setLastCorrelationId(payload.correlation_id);
                debugLogInfo("publish complete", {
                    action: "manual_watering.start",
                    device_id: deviceId,
                    correlation_id: payload.correlation_id,
                    timeout_s: WAIT_ACK_TIMEOUT_S,
                    ts: Date.now()
                });
                showAck("пїЅпїЅпїЅпїЅпїЅпїЅпїЅ пїЅпїЅа ўпїЅпїЅпїЅпїЅ, пїЅпїЅпїЅ пїЅпїЅпїЅвўҐа¦¤пїЅпїЅпїЅпїЅ...");

                const ackMessage = await waitAck(payload.correlation_id, deviceId);
                showAck(ackMessage);

                fetchStatus().catch(console.error);
                // Р§С‚РѕР±С‹ UI С‚РѕС‡РЅРѕ РѕР±РЅРѕРІРёР»СЃСЏ Рё РЅРµ РѕСЃС‚Р°РІР°Р»СЃСЏ РІ СЃРѕСЃС‚РѕСЏРЅРёРё "РЅРµС‚ РґР°РЅРЅС‹С…", С‡РµСЂРµР· СЃРµРєСѓРЅРґСѓ РѕРїСЂР°С€РёРІР°РµРј СЃС‚Р°С‚СѓСЃ РµС‰С‘ СЂР°Р·.
                setTimeout(() => fetchStatus().catch(console.error), 1000);
            } catch (error) {
                console.error("РћС€РёР±РєР° Р·Р°РїСѓСЃРєР° РїРѕР»РёРІР°", error);
                showAck(`РќРµ СѓРґР°Р»РѕСЃСЊ Р·Р°РїСѓСЃС‚РёС‚СЊ РїРѕР»РёРІ вќЊ (${error.message})`);
            } finally {
                setButtonsDisabled(false);
            }
        }

        async function stopWatering() {
            const deviceId = deviceInput.value.trim();

            setButtonsDisabled(true);
            showAck("РћС‚РїСЂР°РІР»СЏРµРј РєРѕРјР°РЅРґСѓ РѕСЃС‚Р°РЅРѕРІРєРё...");

            try {
                const response = await fetch("/api/manual-watering/stop", {
                    method: "POST",
                    headers: { "Content-Type": "application/json" },
                    body: JSON.stringify({ device_id: deviceId })
                });

                if (!response.ok) {
                    const errorPayload = await response.json().catch(() => ({}));
                    throw new Error(errorPayload.detail || `HTTP ${response.status}`);
                }

                const payload = await response.json();
                setLastCorrelationId(payload.correlation_id);
                debugLogInfo("publish complete", {
                    action: "manual_watering.stop",
                    device_id: deviceId,
                    correlation_id: payload.correlation_id,
                    timeout_s: WAIT_ACK_TIMEOUT_S,
                    ts: Date.now()
                });
                showAck("пїЅпїЅпїЅ пїЅпїЅпїЅвўҐа¦¤пїЅпїЅпїЅпїЅ пїЅпїЅв ­пїЅпїЅпїЅпїЅ...");

                const ackMessage = await waitAck(payload.correlation_id, deviceId);
                showAck(ackMessage);

                fetchStatus().catch(console.error);
            } catch (error) {
                console.error("РћС€РёР±РєР° РѕСЃС‚Р°РЅРѕРІРєРё РїРѕР»РёРІР°", error);
                showAck(`РќРµ СѓРґР°Р»РѕСЃСЊ РѕСЃС‚Р°РЅРѕРІРёС‚СЊ РїРѕР»РёРІ вќЊ (${error.message})`);
            } finally {
                setButtonsDisabled(false);
            }
        }

        async function onRebootClick() {
            if (!validateDeviceId()) {
                return;
            }

            const deviceId = deviceInput.value.trim();
            setButtonsDisabled(true);
            showAck("РћС‚РїСЂР°РІР»СЏРµРј РєРѕРјР°РЅРґСѓ РїРµСЂРµР·Р°РіСЂСѓР·РєРё...");

            try {
                const response = await fetch("/api/manual-watering/reboot", {
                    method: "POST",
                    headers: { "Content-Type": "application/json" },
                    body: JSON.stringify({ device_id: deviceId })
                });

                if (!response.ok) {
                    const errorPayload = await response.json().catch(() => ({}));
                    const detailRaw = errorPayload.detail;
                    const detail =
                        Array.isArray(detailRaw)
                            ? detailRaw.map((item) => item.msg || JSON.stringify(item)).join("; ")
                            : detailRaw;
                    throw new Error(detail || `HTTP ${response.status}`);
                }

                const payload = await response.json();
                setLastCorrelationId(payload.correlation_id);
                debugLogInfo("publish complete", {
                    action: "manual_watering.reboot",
                    device_id: deviceId,
                    correlation_id: payload.correlation_id,
                    timeout_s: WAIT_ACK_TIMEOUT_S,
                    ts: Date.now()
                });
                showAck("пїЅпїЅпїЅпїЅпїЅпїЅпїЅ пїЅпїЅаҐ§пїЅпїЅпїЅг§ЄпїЅ пїЅпїЅа ўпїЅпїЅпїЅпїЅ, пїЅпїЅпїЅ пїЅпїЅпїЅвўҐа¦¤пїЅпїЅпїЅпїЅ...");

                const ackMessage = await waitAckForReboot(payload.correlation_id, deviceId);
                showAck(ackMessage);

                fetchStatus().catch(console.error);
            } catch (error) {
                console.error("РћС€РёР±РєР° РїРµСЂРµР·Р°РіСЂСѓР·РєРё СѓСЃС‚СЂРѕР№СЃС‚РІР°", error);
                const rawMessage =
                    error && typeof error === "object" && "message" in error
                        ? error.message
                        : String(error);
                const message = typeof rawMessage === "string" ? rawMessage : JSON.stringify(rawMessage);
                const errorName =
                    error && typeof error === "object" && "name" in error ? error.name : "";

                if (message.includes("MQTT publisher unavailable") || message.includes("503")) {
                    showAck("РЎРµСЂРІРёСЃ РЅРµРґРѕСЃС‚СѓРїРµРЅ, РїРѕРїСЂРѕР±СѓР№С‚Рµ РїРѕР·Р¶Рµ вќЊ");
                } else if (
                    message.includes("Failed to fetch") ||
                    message.includes("NetworkError") ||
                    errorName === "TypeError"
                ) {
                    showAck("РЎРµС‚СЊ РЅРµРґРѕСЃС‚СѓРїРЅР° вќЊ");
                } else {
                    showAck(`РќРµ СѓРґР°Р»РѕСЃСЊ РїРµСЂРµР·Р°РіСЂСѓР·РёС‚СЊ СѓСЃС‚СЂРѕР№СЃС‚РІРѕ вќЊ (${message})`);
                }
            } finally {
                setButtonsDisabled(false);
            }
        }

        async function waitAckForReboot(correlationId, deviceId) {
            const url = `/api/manual-watering/wait-ack?correlation_id=${encodeURIComponent(correlationId)}&timeout_s=${WAIT_ACK_TIMEOUT_S}`;
            setLastWaitAckUrl(url);
            debugLogDebug("WAIT_ACK request", {
                device_id: deviceId || deviceInput.value.trim(),
                correlation_id: correlationId,
                url
            });
            try {
                const response = await fetch(url);
                if (response.status === 408) {
                    debugLogWarn("WAIT_ACK TIMEOUT", { correlation_id: correlationId });
                    setLastAckSummary("408 timeout");
                    return "пїЅпїЅаҐ§пїЅпїЅпїЅг§ЄпїЅ пїЅпїЅ пїЅпїЅпїЅвўҐа¦¤пїЅпїЅпїЅ: пїЅаҐўпїЅиҐ­пїЅ пїЅаҐ¬пїЅ пїЅпїЅпїЅпїЅпїЅпїЅпїЅпїЅ ?";
                }
                if (!response.ok) {
                    const errorPayload = await response.json().catch(() => ({}));
                    const detail = errorPayload.detail || `HTTP ${response.status}`;
                    debugLogError("WAIT_ACK ERROR", { correlation_id: correlationId, detail });
                    setLastAckSummary(`${response.status} error`);
                    return `пїЅпїЅаҐ§пїЅпїЅпїЅг§ЄпїЅ пїЅпїЅ пїЅпїЅпїЅвўҐа¦¤пїЅпїЅпїЅ: ${detail} ?`;
                }
                const payload = await response.json();
                debugLogInfo("WAIT_ACK OK", {
                    correlation_id: correlationId,
                    result: payload.result,
                    status: payload.status
                });
                setLastAckSummary(`${payload.result}/${payload.status ?? "вЂ”"}`);
                if (payload.result === "accepted") {
                    return "пїЅпїЅаҐ§пїЅпїЅпїЅг§ЄпїЅ пїЅпїЅпїЅвўҐа¦¤пїЅпїЅпїЅ пїЅпїЅпїЅа®©пїЅвў®пїЅ ?";
                }
                const reason = payload.reason || payload.result || "пїЅпїЅпїЅпїЅпїЅпїЅпїЅв­ пїЅ пїЅпїЅзЁ­пїЅ";
                setLastAckSummary(reason);
                return `пїЅпїЅаҐ§пїЅпїЅпїЅг§ЄпїЅ пїЅпїЅ пїЅпїЅпїЅвўҐа¦¤пїЅпїЅпїЅ: ${reason} ?`;
            } catch (error) {
                console.error("пїЅиЁЎпїЅпїЅ пїЅпїЅпїЅпїЅпїЅпїЅпїЅпїЅ ACK пїЅпїЅпїЅ пїЅпїЅаҐ§пїЅпїЅпїЅг§ЄпїЅ", error);
                debugLogError("WAIT_ACK ERROR", {
                    correlation_id: correlationId,
                    message: error && error.message ? error.message : String(error)
                });
                setLastAckSummary("network error");
                return "пїЅпїЅаҐ§пїЅпїЅпїЅг§ЄпїЅ пїЅпїЅ пїЅпїЅпїЅвўҐа¦¤пїЅпїЅпїЅ: пїЅпїЅпїЅ пїЅпїЅпїЅпїЅпїЅпїЅгЇ­пїЅ ?";
            }
        }

        async function waitAck(correlationId, deviceId) {
            const url = `/api/manual-watering/wait-ack?correlation_id=${encodeURIComponent(correlationId)}&timeout_s=${WAIT_ACK_TIMEOUT_S}`;
            setLastWaitAckUrl(url);
            debugLogDebug("WAIT_ACK request", {
                device_id: deviceId || deviceInput.value.trim(),
                correlation_id: correlationId,
                url
            });
            try {
                const response = await fetch(url);
                if (response.status === 408) {
                    debugLogWarn("WAIT_ACK TIMEOUT", { correlation_id: correlationId });
                    setLastAckSummary("408 timeout");
                    return "ACK пїЅпїЅ пїЅпїЅпїЅпїЅзҐ­ пїЅ пїЅпїЅпїЅпїЅпїЅпїЅпїЅпїЅ пїЅаҐ¬пїЅ ?";
                }
                if (!response.ok) {
                    const errorPayload = await response.json().catch(() => ({}));
                    const detail = errorPayload.detail || `HTTP ${response.status}`;
                    debugLogError("WAIT_ACK ERROR", { correlation_id: correlationId, detail });
                    setLastAckSummary(`${response.status} error`);
                    return errorPayload.detail || "пїЅиЁЎпїЅпїЅ пїЅпїЅпїЅпїЅпїЅпїЅпїЅпїЅ ACK ?";
                }
                const payload = await response.json();
                debugLogInfo("WAIT_ACK OK", {
                    correlation_id: correlationId,
                    result: payload.result,
                    status: payload.status
                });
                setLastAckSummary(`${payload.result}/${payload.status ?? "вЂ”"}`);
                if (payload.result === "accepted") {
                    return "пїЅпїЅпїЅпїЅпїЅпїЅпїЅ пїЅпїЅпїЅвўҐа¦¤пїЅпїЅпїЅ ?";
                }
                if (payload.result === "rejected") {
                    return "пїЅпїЅпїЅпїЅпїЅпїЅпїЅ пїЅвЄ«пїЅпїЅпїЅпїЅпїЅ ?";
                }
                setLastAckSummary(payload.result);
                return `пїЅвўҐпїЅ пїЅпїЅ пїЅпїЅпїЅа®©пїЅвў : ${payload.result}`;
            } catch (error) {
                console.error("пїЅиЁЎпїЅпїЅ пїЅпїЅпїЅпїЅпїЅпїЅпїЅпїЅ ACK", error);
                debugLogError("WAIT_ACK ERROR", {
                    correlation_id: correlationId,
                    message: error && error.message ? error.message : String(error)
                });
                setLastAckSummary("network error");
                return "пїЅпїЅ г¤ пїЅпїЅпїЅпїЅ пїЅпїЅпїЅпїЅпїЅпїЅпїЅпїЅпїЅ ACK ?";
            }
        }

        function init() {
            stopBtn.disabled = true;
            rebootBtn.disabled = true;
            ensureDebugEnabled().catch(() => {});
            fetchStatus().catch(console.error);
        }

        document.addEventListener("DOMContentLoaded", init);
    </script>
</body>
</html>
