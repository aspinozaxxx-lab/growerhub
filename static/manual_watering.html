<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8" />
    <title>Ручной полив</title>
    <style>
        body {
            font-family: "Segoe UI", sans-serif;
            margin: 40px;
            background: #f5f6fa;
            color: #1e272e;
        }

        h1 {
            margin-bottom: 20px;
        }

        label {
            display: block;
            margin-top: 15px;
            font-weight: 600;
        }

        input[type="text"],
        select {
            padding: 8px 12px;
            margin-top: 6px;
            border-radius: 6px;
            border: 1px solid #d2dae2;
            width: 260px;
            font-size: 14px;
            box-sizing: border-box;
        }

        button {
            padding: 10px 18px;
            margin-top: 20px;
            margin-right: 10px;
            border: none;
            border-radius: 6px;
            background: #1e90ff;
            color: #fff;
            font-size: 15px;
            cursor: pointer;
            transition: background 0.2s ease;
        }

        button:hover:enabled {
            background: #0d6efd;
        }

        button:disabled {
            background: #b0b8c1;
            cursor: not-allowed;
        }

        #onlineStatus,
        #ackResult,
        #progressText {
            margin-top: 18px;
            font-size: 16px;
        }

        #ackResult {
            font-weight: 600;
        }

        #progressContainer {
            margin-top: 24px;
            width: 400px;
            height: 20px;
            background: #dfe4ea;
            border-radius: 10px;
            overflow: hidden;
        }

        #progressBar {
            height: 100%;
            width: 0;
            background: linear-gradient(90deg, #1e90ff, #70a1ff);
            transition: width 0.4s ease;
        }

        .inline-group {
            display: flex;
            align-items: center;
            gap: 20px;
            margin-top: 10px;
        }
    </style>
</head>
<body>
    <h1>Ручной полив</h1>

    <label for="device_id">ID устройства</label>
    <input id="device_id" type="text" placeholder="Например, abc123" />

    <label for="duration">Длительность полива</label>
    <select id="duration">
        <option value="10">10 секунд</option>
        <option value="20" selected>20 секунд</option>
        <option value="30">30 секунд</option>
        <option value="60">60 секунд</option>
    </select>

    <div class="inline-group">
        <button id="startBtn">Полить</button>
        <button id="stopBtn">Остановить</button>
    </div>

    <div id="onlineStatus">Статус устройства: неизвестно</div>
    <div id="ackResult"></div>

    <div id="progressContainer">
        <div id="progressBar"></div>
    </div>
    <div id="progressText">Нет активного полива</div>

    <script>
        // Фиксируем элементы интерфейса, чтобы повторно не искать их в DOM
        const deviceInput = document.getElementById("device_id");
        const durationSelect = document.getElementById("duration");
        const startBtn = document.getElementById("startBtn");
        const stopBtn = document.getElementById("stopBtn");
        const onlineStatusBlock = document.getElementById("onlineStatus");
        const ackResultBlock = document.getElementById("ackResult");
        const progressContainer = document.getElementById("progressContainer");
        const progressBar = document.getElementById("progressBar");
        const progressText = document.getElementById("progressText");

        const slowPollIntervalMs = 5000; // обновление статуса для UI, чтобы показывать онлайн/оффлайн
        const fastPollIntervalMs = 2000; // быстрый опрос во время активного полива

        let slowPollTimer = null;
        let fastPollTimer = null;
        let lastKnownStatus = null;

        function cancelSlowPoll() {
            if (slowPollTimer) {
                clearTimeout(slowPollTimer);
                slowPollTimer = null;
            }
        }

        deviceInput.addEventListener("input", () => {
            // Каждое изменение ID устройства сбрасывает таймеры и заново запрашивает статус.
            cancelSlowPoll();
            stopFastPoll();
            if (!deviceInput.value.trim()) {
                showAck("ID устройства не указан — кнопки заблокированы.");
                setButtonsDisabled(true);
                resetProgress();
                onlineStatusBlock.textContent = "Статус устройства: неизвестно";
                return;
            }
            fetchStatus().catch(console.error);
        });

        startBtn.addEventListener("click", () => {
            if (!validateDeviceId()) {
                return;
            }
            startWatering();
        });

        stopBtn.addEventListener("click", () => {
            if (!validateDeviceId()) {
                return;
            }
            stopWatering();
        });

        function validateDeviceId() {
            const value = deviceInput.value.trim();
            if (!value) {
                showAck("Укажите ID устройства ❗");
                return false;
            }
            return true;
        }

        function setButtonsDisabled(disabled) {
            startBtn.disabled = disabled;
            stopBtn.disabled = disabled;
        }

        function setButtonsForStatus(statusValue, isOnline) {
            if (!isOnline) {
                setButtonsDisabled(true);
                return;
            }

            if (statusValue === "running") {
                startBtn.disabled = true;
                stopBtn.disabled = false;
            } else {
                startBtn.disabled = false;
                stopBtn.disabled = true;
            }
        }

        function resetProgress() {
            progressBar.style.width = "0%";
            progressText.textContent = "Нет активного полива";
        }

        function updateProgressBar(status) {
            if (status.status !== "running" || status.duration_s == null) {
                resetProgress();
                return;
            }

            const duration = status.duration_s;
            const remaining = status.remaining_s ?? duration;
            const elapsed = Math.max(0, duration - remaining);
            const percent = Math.min(100, Math.max(0, (elapsed / duration) * 100));
            progressBar.style.width = `${percent}%`;
            progressText.textContent = `Осталось ${remaining} с из ${duration}`;
        }

        function showAck(message) {
            ackResultBlock.textContent = message;
        }

        function scheduleSlowPoll() {
            cancelSlowPoll();
            slowPollTimer = setTimeout(() => fetchStatus().catch(console.error), slowPollIntervalMs);
        }

        function startFastPoll() {
            if (fastPollTimer) {
                return;
            }
            fastPollTimer = setInterval(() => {
                fetchStatus().catch(console.error);
            }, fastPollIntervalMs);
        }

        function stopFastPoll() {
            if (fastPollTimer) {
                clearInterval(fastPollTimer);
                fastPollTimer = null;
            }
        }

        async function fetchStatus() {
            cancelSlowPoll();
            const deviceId = deviceInput.value.trim();
            if (!deviceId) {
                showAck("ID устройства не задан — статусы не опрашиваются.");
                setButtonsDisabled(true);
                resetProgress();
                return;
            }

            try {
                const response = await fetch(`/api/manual-watering/status?device_id=${encodeURIComponent(deviceId)}`);
                if (response.status === 404) {
                    // Такой device_id сервер ещё не видел — сообщаем пользователю.
                    onlineStatusBlock.textContent = "Устройство не найдено или ещё ни разу не прислало состояние";
                    showAck("Сервер не знает такого device_id — обновите страницу после появления устройства.");
                    setButtonsDisabled(true);
                    resetProgress();
                    stopFastPoll();
                    scheduleSlowPoll();
                    return;
                }
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}`);
                }
                const statusPayload = await response.json();
                lastKnownStatus = statusPayload;
                renderStatus(statusPayload);
            } catch (error) {
                console.error("Не удалось получить статус", error);
                showAck("Ошибка запроса статуса ❌");
                setButtonsDisabled(true);
                resetProgress();
                stopFastPoll();
            } finally {
                scheduleSlowPoll();
            }
        }

        function renderStatus(status) {
            const isOnline = Boolean(status.is_online);
            const lastSeen = status.last_seen_at;
            const textSuffix = lastSeen ? describeLastSeen(lastSeen) : "нет данных";

            if (isOnline) {
                onlineStatusBlock.textContent = `Статус устройства: Онлайн ✅ (последняя активность: ${textSuffix})`;
            } else {
                onlineStatusBlock.textContent = `Статус устройства: Оффлайн ❌ (последняя активность: ${textSuffix})`;
            }

            setButtonsForStatus(status.status, isOnline);

            if (!isOnline) {
                resetProgress();
                stopFastPoll();
                return;
            }

            updateProgressBar(status);

            if (status.status === "running") {
                startFastPoll();
            } else {
                stopFastPoll();
            }
        }

        function describeLastSeen(lastSeenIso) {
            const seen = new Date(lastSeenIso);
            if (Number.isNaN(seen.getTime())) {
                return "время неизвестно";
            }
            const now = new Date();
            const diffSeconds = Math.max(0, Math.floor((now.getTime() - seen.getTime()) / 1000));
            if (diffSeconds < 1) {
                return "менее секунды назад";
            }
            return `${diffSeconds} с назад`;
        }

        async function startWatering() {
            const deviceId = deviceInput.value.trim();
            const duration = Number(durationSelect.value);

            setButtonsDisabled(true);
            showAck("Отправляем команду запуска...");

            try {
                const response = await fetch("/api/manual-watering/start", {
                    method: "POST",
                    headers: { "Content-Type": "application/json" },
                    body: JSON.stringify({ device_id: deviceId, duration_s: duration })
                });

                if (!response.ok) {
                    const errorPayload = await response.json().catch(() => ({}));
                    throw new Error(errorPayload.detail || `HTTP ${response.status}`);
                }

                const payload = await response.json();
                showAck("Команда отправлена, ждём подтверждение...");

                const ackMessage = await waitAck(payload.correlation_id);
                showAck(ackMessage);

                fetchStatus().catch(console.error);
            } catch (error) {
                console.error("Ошибка запуска полива", error);
                showAck(`Не удалось запустить полив ❌ (${error.message})`);
            } finally {
                setButtonsDisabled(false);
            }
        }

        async function stopWatering() {
            const deviceId = deviceInput.value.trim();

            setButtonsDisabled(true);
            showAck("Останавливаем полив...");

            try {
                const response = await fetch("/api/manual-watering/stop", {
                    method: "POST",
                    headers: { "Content-Type": "application/json" },
                    body: JSON.stringify({ device_id: deviceId })
                });

                if (!response.ok) {
                    const errorPayload = await response.json().catch(() => ({}));
                    throw new Error(errorPayload.detail || `HTTP ${response.status}`);
                }

                const payload = await response.json();
                showAck("Ждём подтверждение остановки...");

                const ackMessage = await waitAck(payload.correlation_id);
                showAck(ackMessage);

                fetchStatus().catch(console.error);
            } catch (error) {
                console.error("Ошибка остановки полива", error);
                showAck(`Не удалось остановить полив ❌ (${error.message})`);
            } finally {
                setButtonsDisabled(false);
            }
        }

        async function waitAck(correlationId) {
            // Используем wait-ack, чтобы не спамить фронтендом опрос каждую секунду
            try {
                const response = await fetch(`/api/manual-watering/wait-ack?correlation_id=${encodeURIComponent(correlationId)}&timeout_s=5`);
                if (response.status === 408) {
                    return "ACK не получен в заданное время ❌";
                }
                if (!response.ok) {
                    const errorPayload = await response.json().catch(() => ({}));
                    return errorPayload.detail || "Ошибка ожидания ACK ❌";
                }
                const payload = await response.json();
                if (payload.result === "accepted") {
                    return "Команда подтверждена ✅";
                }
                if (payload.result === "rejected") {
                    return "Команда отклонена ❌";
                }
                return `Ответ от устройства: ${payload.result}`;
            } catch (error) {
                console.error("Ошибка ожидания ACK", error);
                return "Не удалось дождаться ACK ❌";
            }
        }

        // Первичная инициализация: снимаем блокировки и запускаем фоновый опрос статуса.
        function init() {
            stopBtn.disabled = true; // останавливать полив нечего
            fetchStatus().catch(console.error);
        }

        document.addEventListener("DOMContentLoaded", init);
    </script>
</body>
</html>
