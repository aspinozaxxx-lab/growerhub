<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8" />
    <title>Ручной полив</title>
    <style>
        body {
            font-family: "Segoe UI", sans-serif;
            margin: 40px;
            background: #f5f6fa;
            color: #1e272e;
        }

        h1 {
            margin-bottom: 20px;
        }

        label {
            display: block;
            margin-top: 15px;
            font-weight: 600;
        }

        input[type="text"],
        select {
            padding: 8px 12px;
            margin-top: 6px;
            border-radius: 6px;
            border: 1px solid #d2dae2;
            width: 260px;
            font-size: 14px;
            box-sizing: border-box;
        }

        button {
            padding: 10px 18px;
            margin-top: 20px;
            margin-right: 10px;
            border: none;
            border-radius: 6px;
            background: #1e90ff;
            color: #fff;
            font-size: 15px;
            cursor: pointer;
            transition: background 0.2s ease;
        }

        button:hover:enabled {
            background: #0d6efd;
        }

        button:disabled {
            background: #b0b8c1;
            cursor: not-allowed;
        }

        #onlineStatus,
        #ackResult,
        #progressText {
            margin-top: 18px;
            font-size: 16px;
        }

        #ackResult {
            font-weight: 600;
        }

        #progressContainer {
            margin-top: 24px;
            width: 400px;
            height: 20px;
            background: #dfe4ea;
            border-radius: 10px;
            overflow: hidden;
        }

        #progressBar {
            height: 100%;
            width: 0;
            background: linear-gradient(90deg, #1e90ff, #70a1ff);
            transition: width 0.4s ease;
        }

        .inline-group {
            display: flex;
            align-items: center;
            gap: 20px;
            margin-top: 10px;
        }
    </style>
</head>
<body>
    <h1>Ручной полив</h1>

    <div id="deviceInfo" style="margin-bottom: 12px; font-weight: 600;"></div>

    <label for="duration">Длительность полива</label>
    <select id="duration">
        <option value="60">1 минута</option>
        <option value="120" selected>2 минуты</option>
        <option value="180">3 минуты</option>
        <option value="240">4 минуты</option>
        <option value="300">5 минут</option>
        <option value="360">6 минут</option>
        <option value="420">7 минут</option>
        <option value="480">8 минут</option>
        <option value="540">9 минут</option>
        <option value="600">10 минут</option>
        <option value="660">11 минут</option>
        <option value="720">12 минут</option>
        <option value="780">13 минут</option>
        <option value="840">14 минут</option>
        <option value="900">15 минут</option>
    </select>

    <div class="inline-group">
        <button id="startBtn">Запустить полив</button>
        <button id="stopBtn">Остановить</button>
        <button id="rebootBtn">Перезагрузить устройство</button>
    </div>

    <div id="onlineStatus">Введите ID устройства</div>
    <div id="ackResult"></div>

    <div id="progressContainer">
        <div id="progressBar"></div>
    </div>
    <div id="progressText">Нет активного полива</div>

    <script>
        const TOKEN_KEY = 'gh_access_token';
        const accessToken = localStorage.getItem(TOKEN_KEY);

        if (!accessToken) {
            window.location.href = '/static/login.html';
            throw new Error('no token');
        }

        const redirectToLogin = () => {
            localStorage.removeItem(TOKEN_KEY);
            window.location.href = '/static/login.html';
        };

        const authFetch = async (url, options = {}) => {
            // Translitem: universal'nyj fetch s dobavleniem Bearer i obrabotkoj 401/403.
            const opts = { ...options };
            opts.headers = { ...(options.headers || {}), Authorization: `Bearer ${accessToken}` };
            const response = await fetch(url, opts);
            if (response.status === 401 || response.status === 403) {
                redirectToLogin();
            }
            return response;
        };

        const deviceInfo = document.getElementById("deviceInfo");
        const durationSelect = document.getElementById("duration");
        const startBtn = document.getElementById("startBtn");
        const stopBtn = document.getElementById("stopBtn");
        const rebootBtn = document.getElementById("rebootBtn");
        const onlineStatusBlock = document.getElementById("onlineStatus");
        const ackResultBlock = document.getElementById("ackResult");
        const progressBar = document.getElementById("progressBar");
        const progressText = document.getElementById("progressText");
        const params = new URLSearchParams(window.location.search);
        const deviceId = params.get('device_id');
        const WAIT_ACK_TIMEOUT_S =
            (window.APP_SETTINGS && Number(window.APP_SETTINGS.waitAckTimeoutSec)) || 5;

        if (deviceId) {
            deviceInfo.textContent = `Устройство: ${deviceId}`;
        } else {
            deviceInfo.innerHTML = 'Не указано устройство для полива. <a href="/static/index.html">Вернуться на главную</a>';
        }

        const slowPollIntervalMs = 5000;
        const fastPollIntervalMs = 2000;

        let slowPollTimer = null;
        let fastPollTimer = null;

        function setButtonsDisabled(disabled) {
            startBtn.disabled = disabled;
            stopBtn.disabled = disabled;
            rebootBtn.disabled = disabled;
        }

        function resetProgress() {
            progressBar.style.width = "0%";
            progressText.textContent = "Нет активного полива";
        }

        function cancelSlowPoll() {
            if (slowPollTimer) {
                clearTimeout(slowPollTimer);
                slowPollTimer = null;
            }
        }

        function scheduleSlowPoll() {
            cancelSlowPoll();
            slowPollTimer = setTimeout(() => {
                fetchStatus().catch(() => {});
            }, slowPollIntervalMs);
        }

        function startFastPoll() {
            if (!fastPollTimer) {
                fastPollTimer = setInterval(() => {
                    fetchStatus().catch(() => {});
                }, fastPollIntervalMs);
            }
        }

        function stopFastPoll() {
            if (fastPollTimer) {
                clearInterval(fastPollTimer);
                fastPollTimer = null;
            }
        }

        startBtn.addEventListener("click", () => {
            if (!validateDeviceId()) {
                return;
            }
            startWatering();
        });

        stopBtn.addEventListener("click", () => {
            if (!validateDeviceId()) {
                return;
            }
            stopWatering();
        });

        rebootBtn.addEventListener("click", () => {
            if (!validateDeviceId()) {
                return;
            }
            onRebootClick();
        });

        function validateDeviceId() {
            if (!deviceId) {
                showAck("Не указано устройство для полива ❗");
                return false;
            }
            return true;
        }

        async function fetchStatus() {
            cancelSlowPoll();
            if (!deviceId) {
                onlineStatusBlock.textContent = "Не указано устройство для полива";
                showAck("Ne ukazano ustrojstvo dlja poliva.");
                setButtonsDisabled(true);
                resetProgress();
                return;
            }

            try {
                const response = await authFetch(`/api/manual-watering/status?device_id=${encodeURIComponent(deviceId)}`);
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}`);
                }
                const data = await response.json();
                renderStatus(data);
            } catch (_error) {
                showAck("Ошибка запроса статуса ❌");
                setButtonsDisabled(true);
                resetProgress();
                stopFastPoll();
            } finally {
                scheduleSlowPoll();
            }
        }

        function renderStatus(data) {
            const isOnline = Boolean(data.is_online);
            const offlineReason = data.offline_reason;
            const lastSeenText = data.last_seen_at ? describeLastSeen(data.last_seen_at) : "—";

            if (isOnline) {
                onlineStatusBlock.textContent = `Статус: онлайн ✅ (последняя активность: ${lastSeenText})`;
                startBtn.disabled = false;
                stopBtn.disabled = false;
                rebootBtn.disabled = false;
                updateProgressBar(data);
                if (data.status === "running") {
                    startFastPoll();
                } else {
                    stopFastPoll();
                }
                return;
            }

            stopFastPoll();
            setButtonsDisabled(true);

            if (offlineReason === "device_offline") {
                onlineStatusBlock.textContent = "Статус: оффлайн ❌ (устройство не отвечает)";
                showAck("Устройство оффлайн — кнопки заблокированы.");
            } else if (offlineReason === "no_state_yet") {
                onlineStatusBlock.textContent = "Статус: данных пока нет (ждём первое подключение)";
                showAck("Ждём первое подключение устройства — кнопки заблокированы.");
            } else {
                onlineStatusBlock.textContent = "Статус: оффлайн";
            }

            resetProgress();
        }

        function updateProgressBar(status) {
            if (status.status !== "running" || status.duration_s == null) {
                resetProgress();
                return;
            }

            const duration = status.duration_s;
            const remaining = status.remaining_s ?? duration;
            const elapsed = Math.max(0, duration - remaining);
            const percent = Math.min(100, Math.max(0, (elapsed / duration) * 100));
            progressBar.style.width = `${percent}%`;
            progressText.textContent = `Осталось ${remaining} с из ${duration}`;
        }

        function describeLastSeen(lastSeenIso) {
            const seen = new Date(lastSeenIso);
            if (Number.isNaN(seen.getTime())) {
                return "неизвестно";
            }
            const now = new Date();
            const diffSeconds = Math.max(0, Math.floor((now - seen) / 1000));
            if (diffSeconds < 1) {
                return "только что";
            }
            return `${diffSeconds} с назад`;
        }

        function showAck(message) {
            ackResultBlock.textContent = message;
        }

        async function startWatering() {
            const duration = Number(durationSelect.value);

            setButtonsDisabled(true);
            showAck("Отправляем команду запуска...");

            try {
                const response = await authFetch("/api/manual-watering/start", {
                    method: "POST",
                    headers: { "Content-Type": "application/json" },
                    body: JSON.stringify({ device_id: deviceId, duration_s: duration })
                });

                if (!response.ok) {
                    const errorPayload = await response.json().catch(() => ({}));
                    throw new Error(errorPayload.detail || `HTTP ${response.status}`);
                }

                const payload = await response.json();
                showAck("Команда отправлена, ждём подтверждение...");

                const ackMessage = await waitAck(payload.correlation_id, deviceId);
                showAck(ackMessage);

                fetchStatus().catch(() => {});
                setTimeout(() => fetchStatus().catch(() => {}), 1000);
            } catch (error) {
                showAck(`Не удалось запустить полив ❌ (${error instanceof Error ? error.message : String(error)})`);
            } finally {
                setButtonsDisabled(false);
            }
        }

        async function stopWatering() {
            setButtonsDisabled(true);
            showAck("Отправляем команду остановки...");

            try {
                const response = await authFetch("/api/manual-watering/stop", {
                    method: "POST",
                    headers: { "Content-Type": "application/json" },
                    body: JSON.stringify({ device_id: deviceId })
                });

                if (!response.ok) {
                    const errorPayload = await response.json().catch(() => ({}));
                    throw new Error(errorPayload.detail || `HTTP ${response.status}`);
                }

                const payload = await response.json();
                showAck("Ждём подтверждение остановки...");

                const ackMessage = await waitAck(payload.correlation_id, deviceId);
                showAck(ackMessage);

                fetchStatus().catch(() => {});
            } catch (error) {
                showAck(`Не удалось остановить полив ❌ (${error instanceof Error ? error.message : String(error)})`);
            } finally {
                setButtonsDisabled(false);
            }
        }

        async function onRebootClick() {
            setButtonsDisabled(true);
            showAck("Отправляем команду перезагрузки...");

            try {
                const response = await authFetch("/api/manual-watering/reboot", {
                    method: "POST",
                    headers: { "Content-Type": "application/json" },
                    body: JSON.stringify({ device_id: deviceId })
                });

                if (!response.ok) {
                    const errorPayload = await response.json().catch(() => ({}));
                    const detailRaw = errorPayload.detail;
                    const detail =
                        Array.isArray(detailRaw)
                            ? detailRaw.map((item) => item.msg || JSON.stringify(item)).join("; ")
                            : detailRaw;
                    throw new Error(detail || `HTTP ${response.status}`);
                }

                const payload = await response.json();
                showAck("Команда перезагрузки отправлена, ждём подтверждение...");

                const ackMessage = await waitAckForReboot(payload.correlation_id, deviceId);
                showAck(ackMessage);

                fetchStatus().catch(() => {});
            } catch (error) {
                const message =
                    error instanceof Error ? error.message : String(error);
                if (message.includes("MQTT publisher unavailable") || message.includes("503")) {
                    showAck("Сервис недоступен, попробуйте позже ❌");
                } else if (
                    message.includes("Failed to fetch") ||
                    message.includes("NetworkError")
                ) {
                    showAck("Сеть недоступна ❌");
                } else {
                    showAck(`Не удалось перезагрузить устройство ❌ (${message})`);
                }
            } finally {
                setButtonsDisabled(false);
            }
        }

        async function waitAckForReboot(correlationId, deviceId) {
            const url = `/api/manual-watering/wait-ack?correlation_id=${encodeURIComponent(correlationId)}&timeout_s=${WAIT_ACK_TIMEOUT_S}`;
            try {
                const response = await authFetch(url);
                if (response.status === 408) {
                    return "Перезагрузка не подтверждена: превышено время ожидания ❌";
                }
                if (!response.ok) {
                    const errorPayload = await response.json().catch(() => ({}));
                    const detail = errorPayload.detail || `HTTP ${response.status}`;
                    return `Перезагрузка не подтверждена: ${detail} ❌`;
                }
                const payload = await response.json();
                if (payload.result === "accepted") {
                    return "Перезагрузка подтверждена устройством ✅";
                }
                const reason = payload.reason || payload.result || "неизвестная причина";
                return `Перезагрузка не подтверждена: ${reason} ❌`;
            } catch (_error) {
                return "Перезагрузка не подтверждена: сеть недоступна ❌";
            }
        }

        async function waitAck(correlationId, deviceId) {
            const url = `/api/manual-watering/wait-ack?correlation_id=${encodeURIComponent(correlationId)}&timeout_s=${WAIT_ACK_TIMEOUT_S}`;
            try {
                const response = await authFetch(url);
                if (response.status === 408) {
                    return "ACK не получен в заданное время ❌";
                }
                if (!response.ok) {
                    const errorPayload = await response.json().catch(() => ({}));
                    return errorPayload.detail || "Ошибка ожидания ACK ❌";
                }
                const payload = await response.json();
                if (payload.result === "accepted") {
                    return "Команда подтверждена ✅";
                }
                if (payload.result === "rejected") {
                    return "Команда отклонена ❌";
                }
                return `Ответ от устройства: ${payload.result}`;
            } catch (_error) {
                return "Не удалось дождаться ACK ❌";
            }
        }

        function init() {
            stopBtn.disabled = true;
            rebootBtn.disabled = true;
            if (!deviceId) {
                setButtonsDisabled(true);
                onlineStatusBlock.textContent = "Не указано устройство для полива";
                showAck("Ne ukazano ustrojstvo dlja poliva");
                resetProgress();
                return;
            }
            fetchStatus().catch(() => {});
        }

        document.addEventListener("DOMContentLoaded", init);
    </script>
</body>
</html>
