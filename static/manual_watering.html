<!DOCTYPE html>

<html lang="ru">

<head>

    <meta charset="UTF-8" />

    <title>╨а╤Г╤З╨╜╨╛╨╣ ╨┐╨╛╨╗╨╕╨▓</title>

    <style>

        body {

            font-family: "Segoe UI", sans-serif;

            margin: 40px;

            background: #f5f6fa;

            color: #1e272e;

        }



        h1 {

            margin-bottom: 20px;

        }



        label {

            display: block;

            margin-top: 15px;

            font-weight: 600;

        }



        input[type="text"],

        select {

            padding: 8px 12px;

            margin-top: 6px;

            border-radius: 6px;

            border: 1px solid #d2dae2;

            width: 260px;

            font-size: 14px;

            box-sizing: border-box;

        }



        button {

            padding: 10px 18px;

            margin-top: 20px;

            margin-right: 10px;

            border: none;

            border-radius: 6px;

            background: #1e90ff;

            color: #fff;

            font-size: 15px;

            cursor: pointer;

            transition: background 0.2s ease;

        }



        button:hover:enabled {

            background: #0d6efd;

        }



        button:disabled {

            background: #b0b8c1;

            cursor: not-allowed;

        }



        #onlineStatus,

        #ackResult,

        #progressText {

            margin-top: 18px;

            font-size: 16px;

        }



        #ackResult {

            font-weight: 600;

        }



        #progressContainer {

            margin-top: 24px;

            width: 400px;

            height: 20px;

            background: #dfe4ea;

            border-radius: 10px;

            overflow: hidden;

        }



        #progressBar {

            height: 100%;

            width: 0;

            background: linear-gradient(90deg, #1e90ff, #70a1ff);

            transition: width 0.4s ease;

        }



        .inline-group {

            display: flex;

            align-items: center;

            gap: 20px;

            margin-top: 10px;

        }

    </style>

</head>

<body>

    <h1>╨а╤Г╤З╨╜╨╛╨╣ ╨┐╨╛╨╗╨╕╨▓</h1>



    <label for="device_id">ID ╤Г╤Б╤В╤А╨╛╨╣╤Б╤В╨▓╨░</label>

    <input id="device_id" type="text" placeholder="╨Э╨░╨┐╤А╨╕╨╝╨╡╤А, abc123" />



    <label for="duration">╨Ф╨╗╨╕╤В╨╡╨╗╤М╨╜╨╛╤Б╤В╤М ╨┐╨╛╨╗╨╕╨▓╨░</label>

    <select id="duration">

        <option value="10">10 ╤Б╨╡╨║╤Г╨╜╨┤</option>

        <option value="20" selected>20 ╤Б╨╡╨║╤Г╨╜╨┤</option>

        <option value="30">30 ╤Б╨╡╨║╤Г╨╜╨┤</option>

        <option value="60">60 ╤Б╨╡╨║╤Г╨╜╨┤</option>

    </select>



    <div class="inline-group">

        <button id="startBtn">╨Я╨╛╨╗╨╕╤В╤М</button>

        <button id="stopBtn">╨Ю╤Б╤В╨░╨╜╨╛╨▓╨╕╤В╤М</button>

        <button id="rebootBtn" class="btn btn-warning">╨Я╨╡╤А╨╡╨╖╨░╨│╤А╤Г╨╖╨╕╤В╤М ╤Г╤Б╤В╤А╨╛╨╣╤Б╤В╨▓╨╛</button>

    </div>



    <div id="onlineStatus">╨Т╨▓╨╡╨┤╨╕╤В╨╡ ID ╤Г╤Б╤В╤А╨╛╨╣╤Б╤В╨▓╨░</div>

    <div id="ackResult"></div>



    <div id="progressContainer">

        <div id="progressBar"></div>

    </div>

    <div id="progressText">╨Э╨╡╤В ╨░╨║╤В╨╕╨▓╨╜╨╛╨│╨╛ ╨┐╨╛╨╗╨╕╨▓╨░</div>

    <div id="debugPanel" style="display: none; margin-top: 24px; padding: 12px; border: 1px dashed #ced6e0; background: #f1f2f6; font-size: 13px;">

        <div style="font-weight: 600; margin-bottom: 6px;">Debug</div>

        <div>Last corr_id: <span id="debugCorrId">&mdash;</span></div>

        <div>Last wait-ack URL: <span id="debugWaitAckUrl">&mdash;</span></div>

        <div>Last ack: <span id="debugAckInfo">&mdash;</span></div>

    </div>



    <script>

        const deviceInput = document.getElementById("device_id");

        const durationSelect = document.getElementById("duration");

        const startBtn = document.getElementById("startBtn");

        const stopBtn = document.getElementById("stopBtn");

        const rebootBtn = document.getElementById("rebootBtn");

        const onlineStatusBlock = document.getElementById("onlineStatus");

        const ackResultBlock = document.getElementById("ackResult");

        const progressBar = document.getElementById("progressBar");

        const progressText = document.getElementById("progressText");

        const debugPanel = document.getElementById("debugPanel");

        const debugCorrId = document.getElementById("debugCorrId");

        const debugWaitAckUrl = document.getElementById("debugWaitAckUrl");

        const debugAckInfo = document.getElementById("debugAckInfo");



        const slowPollIntervalMs = 5000;

        const fastPollIntervalMs = 2000;



        let slowPollTimer = null;

        let fastPollTimer = null;



        const DEBUG_PREFIX = "[ACKDBG-FE]";

        const WAIT_ACK_TIMEOUT_S = 5;

        const debugState = {

            enabled:

                (typeof process !== "undefined" &&

                    process.env &&

                    process.env.NODE_ENV &&

                    process.env.NODE_ENV !== "production") ||

                false,

            lastCorrelationId: "\u2014",

            lastWaitAckUrl: "\u2014",

            lastAck: "\u2014"

        };



        function debugLogInfo(message, data) {

            if (!debugState.enabled) {

                return;

            }

            console.info(`${DEBUG_PREFIX} ${message}`, data);

        }



        function debugLogDebug(message, data) {

            if (!debugState.enabled) {

                return;

            }

            console.debug(`${DEBUG_PREFIX} ${message}`, data);

        }



        function debugLogWarn(message, data) {

            if (!debugState.enabled) {

                return;

            }

            console.warn(`${DEBUG_PREFIX} ${message}`, data);

        }



        function debugLogError(message, data) {

            if (!debugState.enabled) {

                return;

            }

            console.error(`${DEBUG_PREFIX} ${message}`, data);

        }



        function updateDebugPanel() {

            if (!debugState.enabled || !debugPanel) {

                return;

            }

            debugPanel.style.display = "block";

            if (debugCorrId) {

                debugCorrId.textContent = debugState.lastCorrelationId ?? "\u2014";

            }

            if (debugWaitAckUrl) {

                debugWaitAckUrl.textContent = debugState.lastWaitAckUrl ?? "\u2014";

            }

            if (debugAckInfo) {

                debugAckInfo.textContent = debugState.lastAck ?? "\u2014";

            }

        }



        async function ensureDebugEnabled() {

            if (debugState.enabled) {

                updateDebugPanel();

                return;

            }

            try {

                // TRANSLIT: proveryaem nalichie debug endpointa chtoby vkluchit panel

                const response = await fetch("/_debug/manual-watering/config", { method: "GET" });

                if (response.ok) {

                    debugState.enabled = true;

                    updateDebugPanel();

                }

            } catch (error) {

                // TRANSLIT: pri oshibke prosto ostavlyaem debug vykluchennym

                void error;

            }

        }



        function setLastCorrelationId(correlationId) {

            if (!debugState.enabled) {

                return;

            }

            debugState.lastCorrelationId = correlationId ?? "\u2014";

            debugState.lastAck = "\u2014";

            updateDebugPanel();

        }



        function setLastWaitAckUrl(url) {

            if (!debugState.enabled) {

                return;

            }

            debugState.lastWaitAckUrl = url ?? "\u2014";

            updateDebugPanel();

        }



        function setLastAckSummary(summary) {

            if (!debugState.enabled) {

                return;

            }

            debugState.lastAck = summary ?? "\u2014";

            updateDebugPanel();

        }



        function setButtonsDisabled(disabled) {

            startBtn.disabled = disabled;

            stopBtn.disabled = disabled;

            rebootBtn.disabled = disabled;

        }



        function resetProgress() {

            progressBar.style.width = "0%";

            progressText.textContent = "╨Э╨╡╤В ╨░╨║╤В╨╕╨▓╨╜╨╛╨│╨╛ ╨┐╨╛╨╗╨╕╨▓╨░";

        }



        function cancelSlowPoll() {

            if (slowPollTimer) {

                clearTimeout(slowPollTimer);

                slowPollTimer = null;

            }

        }



        function scheduleSlowPoll() {

            cancelSlowPoll();

            slowPollTimer = setTimeout(() => fetchStatus().catch(console.error), slowPollIntervalMs);

        }



        function startFastPoll() {

            if (!fastPollTimer) {

                fastPollTimer = setInterval(() => {

                    fetchStatus().catch(console.error);

                }, fastPollIntervalMs);

            }

        }



        function stopFastPoll() {

            if (fastPollTimer) {

                clearInterval(fastPollTimer);

                fastPollTimer = null;

            }

        }



        document.addEventListener("input", (event) => {

            if (event.target === deviceInput) {

                cancelSlowPoll();

                stopFastPoll();

                fetchStatus().catch(console.error);

            }

        });



        startBtn.addEventListener("click", () => {

            if (!validateDeviceId()) {

                return;

            }

            startWatering();

        });



        stopBtn.addEventListener("click", () => {

            if (!validateDeviceId()) {

                return;

            }

            stopWatering();

        });



        rebootBtn.addEventListener("click", onRebootClick);



        function validateDeviceId() {

            if (!deviceInput.value.trim()) {

                showAck("╨Э╤Г╨╢╨╜╨╛ ╤Г╨║╨░╨╖╨░╤В╤М ID ╤Г╤Б╤В╤А╨╛╨╣╤Б╤В╨▓╨░ тЭЧ");

                return false;

            }

            return true;

        }



        async function fetchStatus() {

            cancelSlowPoll();

            const deviceId = deviceInput.value.trim();

            if (!deviceId) {

                onlineStatusBlock.textContent = "╨Т╨▓╨╡╨┤╨╕╤В╨╡ ID ╤Г╤Б╤В╤А╨╛╨╣╤Б╤В╨▓╨░";

                showAck("╨Ф╨╗╤П ╨╛╨┐╤А╨╛╤Б╨░ ╤Б╤В╨░╤В╤Г╤Б╨░ ╨╜╤Г╨╢╨╜╨╛ ╤Г╨║╨░╨╖╨░╤В╤М ID." );

                setButtonsDisabled(true);

                resetProgress();

                return;

            }



            try {

                // ╨Я╨╡╤А╨╡╨┤ ╨║╨░╨╢╨┤╤Л╨╝ ╨╖╨░╨┐╤А╨╛╤Б╨╛╨╝ ╨┐╨╛╨┤╤З╨╕╤Й╨░╨╡╨╝ ID ╨╕ ╨║╨╛╨┤╨╕╤А╤Г╨╡╨╝ ╨╡╨│╨╛ ╨▓ URL: ╤А╨╡╨░╨╗╤М╨╜╤Л╨╡ ╨╕╨┤╨╡╨╜╤В╨╕╤Д╨╕╨║╨░╤В╨╛╤А╤Л ╤З╨░╤Б╤В╨╛ ╨║╨╛╨┐╨╕╤А╤Г╤О╤В╤Б╤П ╤Б ╨┐╤А╨╛╨▒╨╡╨╗╨░╨╝╨╕ ╨╕ ╤Б╤В╤А╨╛╨║╨░╨╝╨╕.

                const response = await fetch(`/api/manual-watering/status?device_id=${encodeURIComponent(deviceId)}`);

                if (!response.ok) {

                    throw new Error(`HTTP ${response.status}`);

                }

                const data = await response.json();

                console.log("[╨б╨в╨Р╨в╨г╨б ╨Ю╨в ╨б╨Х╨а╨Т╨Х╨а╨Р]", data);

                renderStatus(data);

            } catch (error) {

                console.error("╨Э╨╡ ╤Г╨┤╨░╨╗╨╛╤Б╤М ╨┐╨╛╨╗╤Г╤З╨╕╤В╤М ╤Б╤В╨░╤В╤Г╤Б", error);

                showAck("╨Ю╤И╨╕╨▒╨║╨░ ╨╖╨░╨┐╤А╨╛╤Б╨░ ╤Б╤В╨░╤В╤Г╤Б╨░ тЭМ");

                setButtonsDisabled(true);

                resetProgress();

                stopFastPoll();

            } finally {

                scheduleSlowPoll();

            }

        }



        function renderStatus(data) {

            const isOnline = Boolean(data.is_online);

            const offlineReason = data.offline_reason;

            const lastSeenText = data.last_seen_at ? describeLastSeen(data.last_seen_at) : "тАФ";



        if (isOnline) {

            onlineStatusBlock.textContent = `╨б╤В╨░╤В╤Г╤Б ╤Г╤Б╤В╤А╨╛╨╣╤Б╤В╨▓╨░: ╨Ю╨╜╨╗╨░╨╣╨╜ тЬЕ (╨┐╨╛╤Б╨╗╨╡╨┤╨╜╤П╤П ╨░╨║╤В╨╕╨▓╨╜╨╛╤Б╤В╤М: ${lastSeenText})`;

            startBtn.disabled = false;

            stopBtn.disabled = false;

            rebootBtn.disabled = false;

            updateProgressBar(data);

            if (data.status === "running") {

                startFastPoll();

            } else {

                stopFastPoll();

                }

                return;

            }



        stopFastPoll();

        setButtonsDisabled(true);



        if (offlineReason === "device_offline") {

            onlineStatusBlock.textContent = "╨б╤В╨░╤В╤Г╤Б ╤Г╤Б╤В╤А╨╛╨╣╤Б╤В╨▓╨░: ╨Ю╤Д╤Д╨╗╨░╨╣╨╜ тЭМ (╤Г╤Б╤В╤А╨╛╨╣╤Б╤В╨▓╨╛ ╨▒╤Л╨╗╨╛ ╨╜╨░ ╤Б╨▓╤П╨╖╨╕, ╨╜╨╛ ╤Б╨╡╨╣╤З╨░╤Б ╨╜╨╡╨┤╨╛╤Б╤В╤Г╨┐╨╜╨╛)";

            showAck("╨г╤Б╤В╤А╨╛╨╣╤Б╤В╨▓╨╛ ╨╛╤Д╤Д╨╗╨░╨╣╨╜ тАФ ╨║╨╜╨╛╨┐╨║╨╕ ╨▒╨╗╨╛╨║╨╕╤А╤Г╨╡╨╝.");

        } else if (offlineReason === "no_state_yet") {

                onlineStatusBlock.textContent = "╨б╤В╨░╤В╤Г╤Б ╤Г╤Б╤В╤А╨╛╨╣╤Б╤В╨▓╨░: ╨╜╨╡╤В ╨┤╨░╨╜╨╜╤Л╤Е тЭУ (╤Г╤Б╤В╤А╨╛╨╣╤Б╤В╨▓╨╛ ╨╡╤Й╤С ╨╜╨╕ ╤А╨░╨╖╤Г ╨╜╨╡ ╨▓╤Л╤Е╨╛╨┤╨╕╨╗╨╛ ╨╜╨░ ╤Б╨▓╤П╨╖╤М)";

                showAck("╨Ц╨┤╤С╨╝ ╨┐╨╡╤А╨▓╨╛╨╡ ╨┐╨╛╨┤╨║╨╗╤О╤З╨╡╨╜╨╕╨╡ ╤Г╤Б╤В╤А╨╛╨╣╤Б╤В╨▓╨░ тАФ ╨║╨╜╨╛╨┐╨║╨╕ ╨╖╨░╨▒╨╗╨╛╨║╨╕╤А╨╛╨▓╨░╨╜╤Л.");

            } else {

                onlineStatusBlock.textContent = "╨б╤В╨░╤В╤Г╤Б ╤Г╤Б╤В╤А╨╛╨╣╤Б╤В╨▓╨░: ╨Ю╤Д╤Д╨╗╨░╨╣╨╜ тЭМ (╨┐╤А╨╕╤З╨╕╨╜╨░ ╨╜╨╡╨╕╨╖╨▓╨╡╤Б╤В╨╜╨░)";

            }



            setButtonsDisabled(true);

            resetProgress();

        }



        function updateProgressBar(status) {

            if (status.status !== "running" || status.duration_s == null) {

                resetProgress();

                return;

            }



            const duration = status.duration_s;

            const remaining = status.remaining_s ?? duration;

            const elapsed = Math.max(0, duration - remaining);

            const percent = Math.min(100, Math.max(0, (elapsed / duration) * 100));

            progressBar.style.width = `${percent}%`;

            progressText.textContent = `╨Ю╤Б╤В╨░╨╗╨╛╤Б╤М ${remaining} ╤Б ╨╕╨╖ ${duration}`;

        }



        function describeLastSeen(lastSeenIso) {

            const seen = new Date(lastSeenIso);

            if (Number.isNaN(seen.getTime())) {

                return "╨▓╤А╨╡╨╝╤П ╨╜╨╡╨╕╨╖╨▓╨╡╤Б╤В╨╜╨╛";

            }

            const now = new Date();

            const diffSeconds = Math.max(0, Math.floor((now - seen) / 1000));

            if (diffSeconds < 1) {

                return "╨╝╨╡╨╜╨╡╨╡ ╤Б╨╡╨║╤Г╨╜╨┤╤Л ╨╜╨░╨╖╨░╨┤";

            }

            return `${diffSeconds} ╤Б ╨╜╨░╨╖╨░╨┤`;

        }



        function showAck(message) {

            ackResultBlock.textContent = message;

        }



        async function startWatering() {

            const deviceId = deviceInput.value.trim();

            const duration = Number(durationSelect.value);



            setButtonsDisabled(true);

            showAck("╨Ю╤В╨┐╤А╨░╨▓╨╗╤П╨╡╨╝ ╨║╨╛╨╝╨░╨╜╨┤╤Г ╨╜╨░ ╨╖╨░╨┐╤Г╤Б╨║...");



            try {

                const response = await fetch("/api/manual-watering/start", {

                    method: "POST",

                    headers: { "Content-Type": "application/json" },

                    body: JSON.stringify({ device_id: deviceId, duration_s: duration })

                });



                if (!response.ok) {

                    const errorPayload = await response.json().catch(() => ({}));

                    throw new Error(errorPayload.detail || `HTTP ${response.status}`);

                }



                const payload = await response.json();

                setLastCorrelationId(payload.correlation_id);

                debugLogInfo("publish complete", {

                    action: "manual_watering.start",

                    device_id: deviceId,

                    correlation_id: payload.correlation_id,

                    timeout_s: WAIT_ACK_TIMEOUT_S,

                    ts: Date.now()

                });

                showAck("я┐╜я┐╜я┐╜я┐╜я┐╜я┐╜я┐╜ я┐╜я┐╜равя┐╜я┐╜я┐╜я┐╜, я┐╜я┐╜я┐╜ я┐╜я┐╜я┐╜тверждя┐╜я┐╜я┐╜я┐╜...");



                const ackMessage = await waitAck(payload.correlation_id, deviceId);

                showAck(ackMessage);



                fetchStatus().catch(console.error);

                // ╨з╤В╨╛╨▒╤Л UI ╤В╨╛╤З╨╜╨╛ ╨╛╨▒╨╜╨╛╨▓╨╕╨╗╤Б╤П ╨╕ ╨╜╨╡ ╨╛╤Б╤В╨░╨▓╨░╨╗╤Б╤П ╨▓ ╤Б╨╛╤Б╤В╨╛╤П╨╜╨╕╨╕ "╨╜╨╡╤В ╨┤╨░╨╜╨╜╤Л╤Е", ╤З╨╡╤А╨╡╨╖ ╤Б╨╡╨║╤Г╨╜╨┤╤Г ╨╛╨┐╤А╨░╤И╨╕╨▓╨░╨╡╨╝ ╤Б╤В╨░╤В╤Г╤Б ╨╡╤Й╤С ╤А╨░╨╖.

                setTimeout(() => fetchStatus().catch(console.error), 1000);

            } catch (error) {

                console.error("╨Ю╤И╨╕╨▒╨║╨░ ╨╖╨░╨┐╤Г╤Б╨║╨░ ╨┐╨╛╨╗╨╕╨▓╨░", error);

                showAck(`╨Э╨╡ ╤Г╨┤╨░╨╗╨╛╤Б╤М ╨╖╨░╨┐╤Г╤Б╤В╨╕╤В╤М ╨┐╨╛╨╗╨╕╨▓ тЭМ (${error.message})`);

            } finally {

                setButtonsDisabled(false);

            }

        }



        async function stopWatering() {

            const deviceId = deviceInput.value.trim();



            setButtonsDisabled(true);

            showAck("╨Ю╤В╨┐╤А╨░╨▓╨╗╤П╨╡╨╝ ╨║╨╛╨╝╨░╨╜╨┤╤Г ╨╛╤Б╤В╨░╨╜╨╛╨▓╨║╨╕...");



            try {

                const response = await fetch("/api/manual-watering/stop", {

                    method: "POST",

                    headers: { "Content-Type": "application/json" },

                    body: JSON.stringify({ device_id: deviceId })

                });



                if (!response.ok) {

                    const errorPayload = await response.json().catch(() => ({}));

                    throw new Error(errorPayload.detail || `HTTP ${response.status}`);

                }



                const payload = await response.json();

                setLastCorrelationId(payload.correlation_id);

                debugLogInfo("publish complete", {

                    action: "manual_watering.stop",

                    device_id: deviceId,

                    correlation_id: payload.correlation_id,

                    timeout_s: WAIT_ACK_TIMEOUT_S,

                    ts: Date.now()

                });

                showAck("я┐╜я┐╜я┐╜ я┐╜я┐╜я┐╜тверждя┐╜я┐╜я┐╜я┐╜ я┐╜я┐╜таня┐╜я┐╜я┐╜я┐╜...");



                const ackMessage = await waitAck(payload.correlation_id, deviceId);

                showAck(ackMessage);



                fetchStatus().catch(console.error);

            } catch (error) {

                console.error("╨Ю╤И╨╕╨▒╨║╨░ ╨╛╤Б╤В╨░╨╜╨╛╨▓╨║╨╕ ╨┐╨╛╨╗╨╕╨▓╨░", error);

                showAck(`╨Э╨╡ ╤Г╨┤╨░╨╗╨╛╤Б╤М ╨╛╤Б╤В╨░╨╜╨╛╨▓╨╕╤В╤М ╨┐╨╛╨╗╨╕╨▓ тЭМ (${error.message})`);

            } finally {

                setButtonsDisabled(false);

            }

        }



        async function onRebootClick() {

            if (!validateDeviceId()) {

                return;

            }



            const deviceId = deviceInput.value.trim();

            setButtonsDisabled(true);

            showAck("╨Ю╤В╨┐╤А╨░╨▓╨╗╤П╨╡╨╝ ╨║╨╛╨╝╨░╨╜╨┤╤Г ╨┐╨╡╤А╨╡╨╖╨░╨│╤А╤Г╨╖╨║╨╕...");



            try {

                const response = await fetch("/api/manual-watering/reboot", {

                    method: "POST",

                    headers: { "Content-Type": "application/json" },

                    body: JSON.stringify({ device_id: deviceId })

                });



                if (!response.ok) {

                    const errorPayload = await response.json().catch(() => ({}));

                    const detailRaw = errorPayload.detail;

                    const detail =

                        Array.isArray(detailRaw)

                            ? detailRaw.map((item) => item.msg || JSON.stringify(item)).join("; ")

                            : detailRaw;

                    throw new Error(detail || `HTTP ${response.status}`);

                }



                const payload = await response.json();

                setLastCorrelationId(payload.correlation_id);

                debugLogInfo("publish complete", {

                    action: "manual_watering.reboot",

                    device_id: deviceId,

                    correlation_id: payload.correlation_id,

                    timeout_s: WAIT_ACK_TIMEOUT_S,

                    ts: Date.now()

                });

                showAck("я┐╜я┐╜я┐╜я┐╜я┐╜я┐╜я┐╜ я┐╜я┐╜резя┐╜я┐╜я┐╜узкя┐╜ я┐╜я┐╜равя┐╜я┐╜я┐╜я┐╜, я┐╜я┐╜я┐╜ я┐╜я┐╜я┐╜тверждя┐╜я┐╜я┐╜я┐╜...");



                const ackMessage = await waitAckForReboot(payload.correlation_id, deviceId);

                showAck(ackMessage);



                fetchStatus().catch(console.error);

            } catch (error) {

                console.error("╨Ю╤И╨╕╨▒╨║╨░ ╨┐╨╡╤А╨╡╨╖╨░╨│╤А╤Г╨╖╨║╨╕ ╤Г╤Б╤В╤А╨╛╨╣╤Б╤В╨▓╨░", error);

                const rawMessage =

                    error && typeof error === "object" && "message" in error

                        ? error.message

                        : String(error);

                const message = typeof rawMessage === "string" ? rawMessage : JSON.stringify(rawMessage);

                const errorName =

                    error && typeof error === "object" && "name" in error ? error.name : "";



                if (message.includes("MQTT publisher unavailable") || message.includes("503")) {

                    showAck("╨б╨╡╤А╨▓╨╕╤Б ╨╜╨╡╨┤╨╛╤Б╤В╤Г╨┐╨╡╨╜, ╨┐╨╛╨┐╤А╨╛╨▒╤Г╨╣╤В╨╡ ╨┐╨╛╨╖╨╢╨╡ тЭМ");

                } else if (

                    message.includes("Failed to fetch") ||

                    message.includes("NetworkError") ||

                    errorName === "TypeError"

                ) {

                    showAck("╨б╨╡╤В╤М ╨╜╨╡╨┤╨╛╤Б╤В╤Г╨┐╨╜╨░ тЭМ");

                } else {

                    showAck(`╨Э╨╡ ╤Г╨┤╨░╨╗╨╛╤Б╤М ╨┐╨╡╤А╨╡╨╖╨░╨│╤А╤Г╨╖╨╕╤В╤М ╤Г╤Б╤В╤А╨╛╨╣╤Б╤В╨▓╨╛ тЭМ (${message})`);

                }

            } finally {

                setButtonsDisabled(false);

            }

        }



        async function waitAckForReboot(correlationId, deviceId) {

            const url = `/api/manual-watering/wait-ack?correlation_id=${encodeURIComponent(correlationId)}&timeout_s=${WAIT_ACK_TIMEOUT_S}`;

            setLastWaitAckUrl(url);

            debugLogDebug("WAIT_ACK request", {

                device_id: deviceId || deviceInput.value.trim(),

                correlation_id: correlationId,

                url

            });

            try {

                const response = await fetch(url);

                if (response.status === 408) {

                    debugLogWarn("WAIT_ACK TIMEOUT", { correlation_id: correlationId });

                    setLastAckSummary("408 timeout");

                    return "я┐╜я┐╜резя┐╜я┐╜я┐╜узкя┐╜ я┐╜я┐╜ я┐╜я┐╜я┐╜тверждя┐╜я┐╜я┐╜: я┐╜ревя┐╜шеня┐╜ я┐╜ремя┐╜ я┐╜я┐╜я┐╜я┐╜я┐╜я┐╜я┐╜я┐╜ ?";

                }

                if (!response.ok) {

                    const errorPayload = await response.json().catch(() => ({}));

                    const detail = errorPayload.detail || `HTTP ${response.status}`;

                    debugLogError("WAIT_ACK ERROR", { correlation_id: correlationId, detail });

                    setLastAckSummary(`${response.status} error`);

                    return `я┐╜я┐╜резя┐╜я┐╜я┐╜узкя┐╜ я┐╜я┐╜ я┐╜я┐╜я┐╜тверждя┐╜я┐╜я┐╜: ${detail} ?`;

                }

                const payload = await response.json();

                debugLogInfo("WAIT_ACK OK", {

                    correlation_id: correlationId,

                    result: payload.result,

                    status: payload.status

                });

                setLastAckSummary(`${payload.result}/${payload.status ?? "тАФ"}`);

                if (payload.result === "accepted") {

                    return "я┐╜я┐╜резя┐╜я┐╜я┐╜узкя┐╜ я┐╜я┐╜я┐╜тверждя┐╜я┐╜я┐╜ я┐╜я┐╜я┐╜ройя┐╜твоя┐╜ ?";

                }

                const reason = payload.reason || payload.result || "я┐╜я┐╜я┐╜я┐╜я┐╜я┐╜я┐╜тная┐╜ я┐╜я┐╜чиня┐╜";

                setLastAckSummary(reason);

                return `я┐╜я┐╜резя┐╜я┐╜я┐╜узкя┐╜ я┐╜я┐╜ я┐╜я┐╜я┐╜тверждя┐╜я┐╜я┐╜: ${reason} ?`;

            } catch (error) {

                console.error("я┐╜шибя┐╜я┐╜ я┐╜я┐╜я┐╜я┐╜я┐╜я┐╜я┐╜я┐╜ ACK я┐╜я┐╜я┐╜ я┐╜я┐╜резя┐╜я┐╜я┐╜узкя┐╜", error);

                debugLogError("WAIT_ACK ERROR", {

                    correlation_id: correlationId,

                    message: error && error.message ? error.message : String(error)

                });

                setLastAckSummary("network error");

                return "я┐╜я┐╜резя┐╜я┐╜я┐╜узкя┐╜ я┐╜я┐╜ я┐╜я┐╜я┐╜тверждя┐╜я┐╜я┐╜: я┐╜я┐╜я┐╜ я┐╜я┐╜я┐╜я┐╜я┐╜я┐╜упня┐╜ ?";

            }

        }



        async function waitAck(correlationId, deviceId) {

            const url = `/api/manual-watering/wait-ack?correlation_id=${encodeURIComponent(correlationId)}&timeout_s=${WAIT_ACK_TIMEOUT_S}`;

            setLastWaitAckUrl(url);

            debugLogDebug("WAIT_ACK request", {

                device_id: deviceId || deviceInput.value.trim(),

                correlation_id: correlationId,

                url

            });

            try {

                const response = await fetch(url);

                if (response.status === 408) {

                    debugLogWarn("WAIT_ACK TIMEOUT", { correlation_id: correlationId });

                    setLastAckSummary("408 timeout");

                    return "ACK я┐╜я┐╜ я┐╜я┐╜я┐╜я┐╜чен я┐╜ я┐╜я┐╜я┐╜я┐╜я┐╜я┐╜я┐╜я┐╜ я┐╜ремя┐╜ ?";

                }

                if (!response.ok) {

                    const errorPayload = await response.json().catch(() => ({}));

                    const detail = errorPayload.detail || `HTTP ${response.status}`;

                    debugLogError("WAIT_ACK ERROR", { correlation_id: correlationId, detail });

                    setLastAckSummary(`${response.status} error`);

                    return errorPayload.detail || "я┐╜шибя┐╜я┐╜ я┐╜я┐╜я┐╜я┐╜я┐╜я┐╜я┐╜я┐╜ ACK ?";

                }

                const payload = await response.json();

                debugLogInfo("WAIT_ACK OK", {

                    correlation_id: correlationId,

                    result: payload.result,

                    status: payload.status

                });

                setLastAckSummary(`${payload.result}/${payload.status ?? "тАФ"}`);

                if (payload.result === "accepted") {

                    return "я┐╜я┐╜я┐╜я┐╜я┐╜я┐╜я┐╜ я┐╜я┐╜я┐╜тверждя┐╜я┐╜я┐╜ ?";

                }

                if (payload.result === "rejected") {

                    return "я┐╜я┐╜я┐╜я┐╜я┐╜я┐╜я┐╜ я┐╜ткля┐╜я┐╜я┐╜я┐╜я┐╜ ?";

                }

                setLastAckSummary(payload.result);

                return `я┐╜твея┐╜ я┐╜я┐╜ я┐╜я┐╜я┐╜ройя┐╜тва: ${payload.result}`;

            } catch (error) {

                console.error("я┐╜шибя┐╜я┐╜ я┐╜я┐╜я┐╜я┐╜я┐╜я┐╜я┐╜я┐╜ ACK", error);

                debugLogError("WAIT_ACK ERROR", {

                    correlation_id: correlationId,

                    message: error && error.message ? error.message : String(error)

                });

                setLastAckSummary("network error");

                return "я┐╜я┐╜ удая┐╜я┐╜я┐╜я┐╜ я┐╜я┐╜я┐╜я┐╜я┐╜я┐╜я┐╜я┐╜я┐╜ ACK ?";

            }

        }



        function init() {

            stopBtn.disabled = true;

            rebootBtn.disabled = true;

            ensureDebugEnabled().catch(() => {});

            fetchStatus().catch(console.error);

        }



        document.addEventListener("DOMContentLoaded", init);

    </script>

</body>

</html>

