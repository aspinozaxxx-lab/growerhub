<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8" />
    <title>Ручной полив</title>
    <style>
        body {
            font-family: "Segoe UI", sans-serif;
            margin: 40px;
            background: #f5f6fa;
            color: #1e272e;
        }

        h1 {
            margin-bottom: 20px;
        }

        label {
            display: block;
            margin-top: 15px;
            font-weight: 600;
        }

        input[type="text"],
        select {
            padding: 8px 12px;
            margin-top: 6px;
            border-radius: 6px;
            border: 1px solid #d2dae2;
            width: 260px;
            font-size: 14px;
            box-sizing: border-box;
        }

        button {
            padding: 10px 18px;
            margin-top: 20px;
            margin-right: 10px;
            border: none;
            border-radius: 6px;
            background: #1e90ff;
            color: #fff;
            font-size: 15px;
            cursor: pointer;
            transition: background 0.2s ease;
        }

        button:hover:enabled {
            background: #0d6efd;
        }

        button:disabled {
            background: #b0b8c1;
            cursor: not-allowed;
        }

        #onlineStatus,
        #ackResult,
        #progressText {
            margin-top: 18px;
            font-size: 16px;
        }

        #ackResult {
            font-weight: 600;
        }

        #progressContainer {
            margin-top: 24px;
            width: 400px;
            height: 20px;
            background: #dfe4ea;
            border-radius: 10px;
            overflow: hidden;
        }

        #progressBar {
            height: 100%;
            width: 0;
            background: linear-gradient(90deg, #1e90ff, #70a1ff);
            transition: width 0.4s ease;
        }

        .inline-group {
            display: flex;
            align-items: center;
            gap: 20px;
            margin-top: 10px;
        }

        #debugPanel {
            display: none;
            margin-top: 24px;
            padding: 12px;
            border: 1px dashed #ced6e0;
            background: #f1f2f6;
            font-size: 13px;
        }

        #debugPanel div {
            margin: 2px 0;
        }
    </style>
</head>
<body>
    <h1>Ручной полив</h1>

    <label for="device_id">ID устройства</label>
    <input id="device_id" type="text" placeholder="Например, abc123" />

    <label for="duration">Длительность полива</label>
    <select id="duration">
        <option value="10">10 секунд</option>
        <option value="20" selected>20 секунд</option>
        <option value="30">30 секунд</option>
        <option value="60">60 секунд</option>
    </select>

    <div class="inline-group">
        <button id="startBtn">Запустить полив</button>
        <button id="stopBtn">Остановить</button>
        <button id="rebootBtn">Перезагрузить устройство</button>
    </div>

    <div id="onlineStatus">Введите ID устройства</div>
    <div id="ackResult"></div>

    <div id="progressContainer">
        <div id="progressBar"></div>
    </div>
    <div id="progressText">Нет активного полива</div>

    <div id="debugPanel">
        <div style="font-weight: 600;">Отладка</div>
        <div>Последний corr_id: <span id="debugCorrId">—</span></div>
        <div>Последний URL ожидания ACK: <span id="debugWaitAckUrl">—</span></div>
        <div>Последний ACK: <span id="debugAckInfo">—</span></div>
    </div>

    <script>
        const deviceInput = document.getElementById("device_id");
        const durationSelect = document.getElementById("duration");
        const startBtn = document.getElementById("startBtn");
        const stopBtn = document.getElementById("stopBtn");
        const rebootBtn = document.getElementById("rebootBtn");
        const onlineStatusBlock = document.getElementById("onlineStatus");
        const ackResultBlock = document.getElementById("ackResult");
        const progressBar = document.getElementById("progressBar");
        const progressText = document.getElementById("progressText");
        const debugPanel = document.getElementById("debugPanel");
        const debugCorrId = document.getElementById("debugCorrId");
        const debugWaitAckUrl = document.getElementById("debugWaitAckUrl");
        const debugAckInfo = document.getElementById("debugAckInfo");

        const slowPollIntervalMs = 5000;
        const fastPollIntervalMs = 2000;

        let slowPollTimer = null;
        let fastPollTimer = null;

        const DEBUG_PREFIX = "[ACKDBG-FE]";
        const WAIT_ACK_TIMEOUT_S = 5;
        const debugState = {
            enabled:
                (typeof process !== "undefined" &&
                    process.env &&
                    process.env.NODE_ENV &&
                    process.env.NODE_ENV !== "production") ||
                false,
            lastCorrelationId: "—",
            lastWaitAckUrl: "—",
            lastAck: "—"
        };

        function debugLogInfo(message, data) {
            if (!debugState.enabled) return;
            console.info(`${DEBUG_PREFIX} ${message}`, data);
        }

        function debugLogDebug(message, data) {
            if (!debugState.enabled) return;
            console.debug(`${DEBUG_PREFIX} ${message}`, data);
        }

        function debugLogWarn(message, data) {
            if (!debugState.enabled) return;
            console.warn(`${DEBUG_PREFIX} ${message}`, data);
        }

        function debugLogError(message, data) {
            if (!debugState.enabled) return;
            console.error(`${DEBUG_PREFIX} ${message}`, data);
        }

        function updateDebugPanel() {
            if (!debugState.enabled) return;
            debugPanel.style.display = "block";
            debugCorrId.textContent = debugState.lastCorrelationId;
            debugWaitAckUrl.textContent = debugState.lastWaitAckUrl;
            debugAckInfo.textContent = debugState.lastAck;
        }

        async function ensureDebugEnabled() {
            if (debugState.enabled) {
                updateDebugPanel();
                return;
            }
            try {
                const response = await fetch("/_debug/manual-watering/config", { method: "GET" });
                if (response.ok) {
                    debugState.enabled = true;
                    updateDebugPanel();
                }
            } catch (error) {
                // если endpoint недоступен — игнорируем
            }
        }

        function setLastCorrelationId(correlationId) {
            if (!debugState.enabled) return;
            debugState.lastCorrelationId = correlationId ?? "—";
            debugState.lastAck = "—";
            updateDebugPanel();
        }

        function setLastWaitAckUrl(url) {
            if (!debugState.enabled) return;
            debugState.lastWaitAckUrl = url ?? "—";
            updateDebugPanel();
        }

        function setLastAckSummary(summary) {
            if (!debugState.enabled) return;
            debugState.lastAck = summary ?? "—";
            updateDebugPanel();
        }

        function setButtonsDisabled(disabled) {
            startBtn.disabled = disabled;
            stopBtn.disabled = disabled;
            rebootBtn.disabled = disabled;
        }

        function resetProgress() {
            progressBar.style.width = "0%";
            progressText.textContent = "Нет активного полива";
        }

        function cancelSlowPoll() {
            if (slowPollTimer) {
                clearTimeout(slowPollTimer);
                slowPollTimer = null;
            }
        }

        function scheduleSlowPoll() {
            cancelSlowPoll();
            slowPollTimer = setTimeout(() => fetchStatus().catch(console.error), slowPollIntervalMs);
        }

        function startFastPoll() {
            if (!fastPollTimer) {
                fastPollTimer = setInterval(() => fetchStatus().catch(console.error), fastPollIntervalMs);
            }
        }

        function stopFastPoll() {
            if (fastPollTimer) {
                clearInterval(fastPollTimer);
                fastPollTimer = null;
            }
        }

        document.addEventListener("input", (event) => {
            if (event.target === deviceInput) {
                cancelSlowPoll();
                stopFastPoll();
                fetchStatus().catch(console.error);
            }
        });

        startBtn.addEventListener("click", () => {
            if (!validateDeviceId()) return;
            startWatering();
        });

        stopBtn.addEventListener("click", () => {
            if (!validateDeviceId()) return;
            stopWatering();
        });

        rebootBtn.addEventListener("click", () => {
            if (!validateDeviceId()) return;
            onRebootClick();
        });

        function validateDeviceId() {
            if (!deviceInput.value.trim()) {
                showAck("Нужно указать ID устройства ❗");
                return false;
            }
            return true;
        }

        async function fetchStatus() {
            cancelSlowPoll();
            const deviceId = deviceInput.value.trim();
            if (!deviceId) {
                onlineStatusBlock.textContent = "Введите ID устройства";
                showAck("Для опроса статуса нужно указать ID.");
                setButtonsDisabled(true);
                resetProgress();
                return;
            }

            try {
                const response = await fetch(`/api/manual-watering/status?device_id=${encodeURIComponent(deviceId)}`);
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}`);
                }
                const data = await response.json();
                console.log("[Статус устройства]", data);
                renderStatus(data);
            } catch (error) {
                console.error("Ошибка запроса статуса", error);
                showAck("Ошибка запроса статуса ❌");
                setButtonsDisabled(true);
                resetProgress();
                stopFastPoll();
            } finally {
                scheduleSlowPoll();
            }
        }

        function renderStatus(data) {
            const isOnline = Boolean(data.is_online);
            const offlineReason = data.offline_reason;
            const lastSeenText = data.last_seen_at ? describeLastSeen(data.last_seen_at) : "—";

            if (isOnline) {
                onlineStatusBlock.textContent = `Статус устройства: Онлайн ✅ (последняя активность: ${lastSeenText})`;
                startBtn.disabled = false;
                stopBtn.disabled = false;
                rebootBtn.disabled = false;
                updateProgressBar(data);
                if (data.status === "running") {
                    startFastPoll();
                } else {
                    stopFastPoll();
                }
                return;
            }

            stopFastPoll();
            setButtonsDisabled(true);

            if (offlineReason === "device_offline") {
                onlineStatusBlock.textContent = "Статус устройства: Оффлайн ❌ (устройство не отвечает)";
                showAck("Устройство оффлайн — кнопки блокируем.");
            } else if (offlineReason === "no_state_yet") {
                onlineStatusBlock.textContent = "Статус устройства: нет данных (ждём первое подключение)";
                showAck("Ждём первое подключение устройства — кнопки заблокированы.");
            } else {
                onlineStatusBlock.textContent = "Статус устройства: оффлайн (нет свежего статуса)";
            }

            setButtonsDisabled(true);
            resetProgress();
        }

        function updateProgressBar(status) {
            if (status.status !== "running" || status.duration_s == null) {
                resetProgress();
                return;
            }

            const duration = status.duration_s;
            const remaining = status.remaining_s ?? duration;
            const elapsed = Math.max(0, duration - remaining);
            const percent = Math.min(100, Math.max(0, (elapsed / duration) * 100));
            progressBar.style.width = `${percent}%`;
            progressText.textContent = `Осталось ${remaining} с из ${duration}`;
        }

        function describeLastSeen(lastSeenIso) {
            const seen = new Date(lastSeenIso);
            if (Number.isNaN(seen.getTime())) {
                return "время неизвестно";
            }
            const now = new Date();
            const diffSeconds = Math.max(0, Math.floor((now - seen) / 1000));
            if (diffSeconds < 1) {
                return "менее секунды назад";
            }
            return `${diffSeconds} с назад`;
        }

        function showAck(message) {
            ackResultBlock.textContent = message;
        }

        async function startWatering() {
            const deviceId = deviceInput.value.trim();
            const duration = Number(durationSelect.value);

            setButtonsDisabled(true);
            showAck("Отправляем команду на запуск...");

            try {
                const response = await fetch("/api/manual-watering/start", {
                    method: "POST",
                    headers: { "Content-Type": "application/json" },
                    body: JSON.stringify({ device_id: deviceId, duration_s: duration })
                });

                if (!response.ok) {
                    const errorPayload = await response.json().catch(() => ({}));
                    throw new Error(errorPayload.detail || `HTTP ${response.status}`);
                }

                const payload = await response.json();
                setLastCorrelationId(payload.correlation_id);
                debugLogInfo("publish complete", {
                    action: "manual_watering.start",
                    device_id: deviceId,
                    correlation_id: payload.correlation_id,
                    timeout_s: WAIT_ACK_TIMEOUT_S,
                    ts: Date.now()
                });
                showAck("Команда отправлена, ждём подтверждение...");

                const ackMessage = await waitAck(payload.correlation_id, deviceId);
                showAck(ackMessage);

                fetchStatus().catch(console.error);
                setTimeout(() => fetchStatus().catch(console.error), 1000);
            } catch (error) {
                console.error("Ошибка запуска полива", error);
                showAck(`Не удалось запустить полив ❌ (${error.message})`);
            } finally {
                setButtonsDisabled(false);
            }
        }

        async function stopWatering() {
            const deviceId = deviceInput.value.trim();

            setButtonsDisabled(true);
            showAck("Отправляем команду остановки...");

            try {
                const response = await fetch("/api/manual-watering/stop", {
                    method: "POST",
                    headers: { "Content-Type": "application/json" },
                    body: JSON.stringify({ device_id: deviceId })
                });

                if (!response.ok) {
                    const errorPayload = await response.json().catch(() => ({}));
                    throw new Error(errorPayload.detail || `HTTP ${response.status}`);
                }

                const payload = await response.json();
                setLastCorrelationId(payload.correlation_id);
                debugLogInfo("publish complete", {
                    action: "manual_watering.stop",
                    device_id: deviceId,
                    correlation_id: payload.correlation_id,
                    timeout_s: WAIT_ACK_TIMEOUT_S,
                    ts: Date.now()
                });
                showAck("Ждём подтверждение остановки...");

                const ackMessage = await waitAck(payload.correlation_id, deviceId);
                showAck(ackMessage);

                fetchStatus().catch(console.error);
            } catch (error) {
                console.error("Ошибка остановки полива", error);
                showAck(`Не удалось остановить полив ❌ (${error.message})`);
            } finally {
                setButtonsDisabled(false);
            }
        }

        async function onRebootClick() {
            const deviceId = deviceInput.value.trim();
            setButtonsDisabled(true);
            showAck("Отправляем команду перезагрузки...");

            try {
                const response = await fetch("/api/manual-watering/reboot", {
                    method: "POST",
                    headers: { "Content-Type": "application/json" },
                    body: JSON.stringify({ device_id: deviceId })
                });

                if (!response.ok) {
                    const errorPayload = await response.json().catch(() => ({}));
                    const detailRaw = errorPayload.detail;
                    const detail =
                        Array.isArray(detailRaw)
                            ? detailRaw.map((item) => item.msg || JSON.stringify(item)).join("; ")
                            : detailRaw;
                    throw new Error(detail || `HTTP ${response.status}`);
                }

                const payload = await response.json();
                setLastCorrelationId(payload.correlation_id);
                debugLogInfo("publish complete", {
                    action: "manual_watering.reboot",
                    device_id: deviceId,
                    correlation_id: payload.correlation_id,
                    timeout_s: WAIT_ACK_TIMEOUT_S,
                    ts: Date.now()
                });
                showAck("Команда перезагрузки отправлена, ждём подтверждение...");

                const ackMessage = await waitAckForReboot(payload.correlation_id, deviceId);
                showAck(ackMessage);

                fetchStatus().catch(console.error);
            } catch (error) {
                console.error("Ошибка перезагрузки устройства", error);
                const rawMessage =
                    error && typeof error === "object" && "message" in error
                        ? error.message
                        : String(error);
                const message = typeof rawMessage === "string" ? rawMessage : JSON.stringify(rawMessage);
                const errorName =
                    error && typeof error === "object" && "name" in error ? error.name : "";

                if (message.includes("MQTT publisher unavailable") || message.includes("503")) {
                    showAck("Сервис недоступен, попробуйте позже ❌");
                } else if (
                    message.includes("Failed to fetch") ||
                    message.includes("NetworkError") ||
                    errorName === "TypeError"
                ) {
                    showAck("Сеть недоступна ❌");
                } else {
                    showAck(`Не удалось перезагрузить устройство ❌ (${message})`);
                }
            } finally {
                setButtonsDisabled(false);
            }
        }

        async function waitAckForReboot(correlationId, deviceId) {
            const url = `/api/manual-watering/wait-ack?correlation_id=${encodeURIComponent(correlationId)}&timeout_s=${WAIT_ACK_TIMEOUT_S}`;
            setLastWaitAckUrl(url);
            debugLogDebug("WAIT_ACK request", {
                device_id: deviceId || deviceInput.value.trim(),
                correlation_id: correlationId,
                url
            });
            try {
                const response = await fetch(url);
                if (response.status === 408) {
                    debugLogWarn("WAIT_ACK TIMEOUT", { correlation_id: correlationId });
                    setLastAckSummary("408 timeout");
                    return "Перезагрузка не подтверждена: превышено время ожидания ❌";
                }
                if (!response.ok) {
                    const errorPayload = await response.json().catch(() => ({}));
                    const detail = errorPayload.detail || `HTTP ${response.status}`;
                    debugLogError("WAIT_ACK ERROR", { correlation_id: correlationId, detail });
                    setLastAckSummary(`${response.status} error`);
                    return `Перезагрузка не подтверждена: ${detail} ❌`;
                }
                const payload = await response.json();
                debugLogInfo("WAIT_ACK OK", {
                    correlation_id: correlationId,
                    result: payload.result,
                    status: payload.status
                });
                setLastAckSummary(`${payload.result}/${payload.status ?? "—"}`);
                if (payload.result === "accepted") {
                    return "Перезагрузка подтверждена устройством ✅";
                }
                const reason = payload.reason || payload.result || "неизвестная причина";
                setLastAckSummary(reason);
                return `Перезагрузка не подтверждена: ${reason} ❌`;
            } catch (error) {
                console.error("Ошибка ожидания ACK для перезагрузки", error);
                debugLogError("WAIT_ACK ERROR", {
                    correlation_id: correlationId,
                    message: error && error.message ? error.message : String(error)
                });
                setLastAckSummary("network error");
                return "Перезагрузка не подтверждена: сеть недоступна ❌";
            }
        }

        async function waitAck(correlationId, deviceId) {
            const url = `/api/manual-watering/wait-ack?correlation_id=${encodeURIComponent(correlationId)}&timeout_s=${WAIT_ACK_TIMEOUT_S}`;
            setLastWaitAckUrl(url);
            debugLogDebug("WAIT_ACK request", {
                device_id: deviceId || deviceInput.value.trim(),
                correlation_id: correlationId,
                url
            });
            try {
                const response = await fetch(url);
                if (response.status === 408) {
                    debugLogWarn("WAIT_ACK TIMEOUT", { correlation_id: correlationId });
                    setLastAckSummary("408 timeout");
                    return "ACK не получен в заданное время ❌";
                }
                if (!response.ok) {
                    const errorPayload = await response.json().catch(() => ({}));
                    const detail = errorPayload.detail || `HTTP ${response.status}`;
                    debugLogError("WAIT_ACK ERROR", { correlation_id: correlationId, detail });
                    setLastAckSummary(`${response.status} error`);
                    return errorPayload.detail || "Ошибка ожидания ACK ❌";
                }
                const payload = await response.json();
                debugLogInfo("WAIT_ACK OK", {
                    correlation_id: correlationId,
                    result: payload.result,
                    status: payload.status
                });
                setLastAckSummary(`${payload.result}/${payload.status ?? "—"}`);
                if (payload.result === "accepted") {
                    return "Команда подтверждена ✅";
                }
                if (payload.result === "rejected") {
                    return "Команда отклонена ❌";
                }
                setLastAckSummary(payload.result);
                return `Ответ от устройства: ${payload.result}`;
            } catch (error) {
                console.error("Ошибка ожидания ACK", error);
                debugLogError("WAIT_ACK ERROR", {
                    correlation_id: correlationId,
                    message: error && error.message ? error.message : String(error)
                });
                setLastAckSummary("network error");
                return "Не удалось дождаться ACK ❌";
            }
        }

        function init() {
            stopBtn.disabled = true;
            rebootBtn.disabled = true;
            ensureDebugEnabled().catch(() => {});
            fetchStatus().catch(console.error);
        }

        document.addEventListener("DOMContentLoaded", init);
    </script>
</body>
</html>
