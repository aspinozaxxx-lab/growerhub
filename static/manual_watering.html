<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8" />
    <title>Ручной полив</title>
    <style>
        body {
            font-family: "Segoe UI", sans-serif;
            margin: 40px;
            background: #f5f6fa;
            color: #1e272e;
        }

        h1 {
            margin-bottom: 20px;
        }

        label {
            display: block;
            margin-top: 15px;
            font-weight: 600;
        }

        input[type="text"],
        select {
            padding: 8px 12px;
            margin-top: 6px;
            border-radius: 6px;
            border: 1px solid #d2dae2;
            width: 260px;
            font-size: 14px;
            box-sizing: border-box;
        }

        button {
            padding: 10px 18px;
            margin-top: 20px;
            margin-right: 10px;
            border: none;
            border-radius: 6px;
            background: #1e90ff;
            color: #fff;
            font-size: 15px;
            cursor: pointer;
            transition: background 0.2s ease;
        }

        button:hover:enabled {
            background: #0d6efd;
        }

        button:disabled {
            background: #b0b8c1;
            cursor: not-allowed;
        }

        #onlineStatus,
        #ackResult,
        #progressText {
            margin-top: 18px;
            font-size: 16px;
        }

        #ackResult {
            font-weight: 600;
        }

        #progressContainer {
            margin-top: 24px;
            width: 400px;
            height: 20px;
            background: #dfe4ea;
            border-radius: 10px;
            overflow: hidden;
        }

        #progressBar {
            height: 100%;
            width: 0;
            background: linear-gradient(90deg, #1e90ff, #70a1ff);
            transition: width 0.4s ease;
        }

        .inline-group {
            display: flex;
            align-items: center;
            gap: 20px;
            margin-top: 10px;
        }
    </style>
</head>
<body>
    <h1>Ручной полив</h1>

    <label for="device_id">ID устройства</label>
    <input id="device_id" type="text" placeholder="Например, abc123" />

    <label for="duration">Длительность полива</label>
    <select id="duration">
        <option value="10">10 секунд</option>
        <option value="20" selected>20 секунд</option>
        <option value="30">30 секунд</option>
        <option value="60">60 секунд</option>
    </select>

    <div class="inline-group">
        <button id="startBtn">Полить</button>
        <button id="stopBtn">Остановить</button>
    </div>

    <div id="onlineStatus">Введите ID устройства</div>
    <div id="ackResult"></div>

    <div id="progressContainer">
        <div id="progressBar"></div>
    </div>
    <div id="progressText">Нет активного полива</div>

    <script>
        const deviceInput = document.getElementById("device_id");
        const durationSelect = document.getElementById("duration");
        const startBtn = document.getElementById("startBtn");
        const stopBtn = document.getElementById("stopBtn");
        const onlineStatusBlock = document.getElementById("onlineStatus");
        const ackResultBlock = document.getElementById("ackResult");
        const progressBar = document.getElementById("progressBar");
        const progressText = document.getElementById("progressText");

        const slowPollIntervalMs = 5000;
        const fastPollIntervalMs = 2000;

        let slowPollTimer = null;
        let fastPollTimer = null;

        function setButtonsDisabled(disabled) {
            startBtn.disabled = disabled;
            stopBtn.disabled = disabled;
        }

        function resetProgress() {
            progressBar.style.width = "0%";
            progressText.textContent = "Нет активного полива";
        }

        function cancelSlowPoll() {
            if (slowPollTimer) {
                clearTimeout(slowPollTimer);
                slowPollTimer = null;
            }
        }

        function scheduleSlowPoll() {
            cancelSlowPoll();
            slowPollTimer = setTimeout(() => fetchStatus().catch(console.error), slowPollIntervalMs);
        }

        function startFastPoll() {
            if (!fastPollTimer) {
                fastPollTimer = setInterval(() => {
                    fetchStatus().catch(console.error);
                }, fastPollIntervalMs);
            }
        }

        function stopFastPoll() {
            if (fastPollTimer) {
                clearInterval(fastPollTimer);
                fastPollTimer = null;
            }
        }

        document.addEventListener("input", (event) => {
            if (event.target === deviceInput) {
                cancelSlowPoll();
                stopFastPoll();
                fetchStatus().catch(console.error);
            }
        });

        startBtn.addEventListener("click", () => {
            if (!validateDeviceId()) {
                return;
            }
            startWatering();
        });

        stopBtn.addEventListener("click", () => {
            if (!validateDeviceId()) {
                return;
            }
            stopWatering();
        });

        function validateDeviceId() {
            if (!deviceInput.value.trim()) {
                showAck("Нужно указать ID устройства ❗");
                return false;
            }
            return true;
        }

        async function fetchStatus() {
            cancelSlowPoll();
            const deviceId = deviceInput.value.trim();
            if (!deviceId) {
                onlineStatusBlock.textContent = "Введите ID устройства";
                showAck("Для опроса статуса нужно указать ID." );
                setButtonsDisabled(true);
                resetProgress();
                return;
            }

            try {
                // Перед каждым запросом подчищаем ID и кодируем его в URL: реальные идентификаторы часто копируются с пробелами и строками.
                const response = await fetch(`/api/manual-watering/status?device_id=${encodeURIComponent(deviceId)}`);
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}`);
                }
                const data = await response.json();
                console.log("[СТАТУС ОТ СЕРВЕРА]", data);
                renderStatus(data);
            } catch (error) {
                console.error("Не удалось получить статус", error);
                showAck("Ошибка запроса статуса ❌");
                setButtonsDisabled(true);
                resetProgress();
                stopFastPoll();
            } finally {
                scheduleSlowPoll();
            }
        }

        function renderStatus(data) {
            const isOnline = Boolean(data.is_online);
            const offlineReason = data.offline_reason;
            const lastSeenText = data.last_seen_at ? describeLastSeen(data.last_seen_at) : "—";

            if (isOnline) {
                onlineStatusBlock.textContent = `Статус устройства: Онлайн ✅ (последняя активность: ${lastSeenText})`;
                startBtn.disabled = false;
                stopBtn.disabled = false;
                updateProgressBar(data);
                if (data.status === "running") {
                    startFastPoll();
                } else {
                    stopFastPoll();
                }
                return;
            }

            stopFastPoll();

            if (offlineReason === "device_offline") {
                onlineStatusBlock.textContent = "Статус устройства: Оффлайн ❌ (устройство было на связи, но сейчас недоступно)";
                showAck("Устройство оффлайн — кнопки блокируем.");
            } else if (offlineReason === "no_state_yet") {
                onlineStatusBlock.textContent = "Статус устройства: нет данных ❓ (устройство ещё ни разу не выходило на связь)";
                showAck("Ждём первое подключение устройства — кнопки заблокированы.");
            } else {
                onlineStatusBlock.textContent = "Статус устройства: Оффлайн ❌ (причина неизвестна)";
            }

            setButtonsDisabled(true);
            resetProgress();
        }

        function updateProgressBar(status) {
            if (status.status !== "running" || status.duration_s == null) {
                resetProgress();
                return;
            }

            const duration = status.duration_s;
            const remaining = status.remaining_s ?? duration;
            const elapsed = Math.max(0, duration - remaining);
            const percent = Math.min(100, Math.max(0, (elapsed / duration) * 100));
            progressBar.style.width = `${percent}%`;
            progressText.textContent = `Осталось ${remaining} с из ${duration}`;
        }

        function describeLastSeen(lastSeenIso) {
            const seen = new Date(lastSeenIso);
            if (Number.isNaN(seen.getTime())) {
                return "время неизвестно";
            }
            const now = new Date();
            const diffSeconds = Math.max(0, Math.floor((now - seen) / 1000));
            if (diffSeconds < 1) {
                return "менее секунды назад";
            }
            return `${diffSeconds} с назад`;
        }

        function showAck(message) {
            ackResultBlock.textContent = message;
        }

        async function startWatering() {
            const deviceId = deviceInput.value.trim();
            const duration = Number(durationSelect.value);

            setButtonsDisabled(true);
            showAck("Отправляем команду на запуск...");

            try {
                const response = await fetch("/api/manual-watering/start", {
                    method: "POST",
                    headers: { "Content-Type": "application/json" },
                    body: JSON.stringify({ device_id: deviceId, duration_s: duration })
                });

                if (!response.ok) {
                    const errorPayload = await response.json().catch(() => ({}));
                    throw new Error(errorPayload.detail || `HTTP ${response.status}`);
                }

                const payload = await response.json();
                showAck("Команда отправлена, ждём подтверждение...");

                const ackMessage = await waitAck(payload.correlation_id);
                showAck(ackMessage);

                fetchStatus().catch(console.error);
                // Чтобы UI точно обновился и не оставался в состоянии "нет данных", через секунду опрашиваем статус ещё раз.
                setTimeout(() => fetchStatus().catch(console.error), 1000);
            } catch (error) {
                console.error("Ошибка запуска полива", error);
                showAck(`Не удалось запустить полив ❌ (${error.message})`);
            } finally {
                setButtonsDisabled(false);
            }
        }

        async function stopWatering() {
            const deviceId = deviceInput.value.trim();

            setButtonsDisabled(true);
            showAck("Отправляем команду остановки...");

            try {
                const response = await fetch("/api/manual-watering/stop", {
                    method: "POST",
                    headers: { "Content-Type": "application/json" },
                    body: JSON.stringify({ device_id: deviceId })
                });

                if (!response.ok) {
                    const errorPayload = await response.json().catch(() => ({}));
                    throw new Error(errorPayload.detail || `HTTP ${response.status}`);
                }

                const payload = await response.json();
                showAck("Ждём подтверждение остановки...");

                const ackMessage = await waitAck(payload.correlation_id);
                showAck(ackMessage);

                fetchStatus().catch(console.error);
            } catch (error) {
                console.error("Ошибка остановки полива", error);
                showAck(`Не удалось остановить полив ❌ (${error.message})`);
            } finally {
                setButtonsDisabled(false);
            }
        }

        async function waitAck(correlationId) {
            try {
                const response = await fetch(`/api/manual-watering/wait-ack?correlation_id=${encodeURIComponent(correlationId)}&timeout_s=5`);
                if (response.status === 408) {
                    return "ACK не получен в заданное время ❌";
                }
                if (!response.ok) {
                    const errorPayload = await response.json().catch(() => ({}));
                    return errorPayload.detail || "Ошибка ожидания ACK ❌";
                }
                const payload = await response.json();
                if (payload.result === "accepted") {
                    return "Команда подтверждена ✅";
                }
                if (payload.result === "rejected") {
                    return "Команда отклонена ❌";
                }
                return `Ответ от устройства: ${payload.result}`;
            } catch (error) {
                console.error("Ошибка ожидания ACK", error);
                return "Не удалось дождаться ACK ❌";
            }
        }

        function init() {
            stopBtn.disabled = true;
            fetchStatus().catch(console.error);
        }

        document.addEventListener("DOMContentLoaded", init);
    </script>
</body>
</html>
